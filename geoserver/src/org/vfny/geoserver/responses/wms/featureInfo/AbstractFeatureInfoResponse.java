package org.vfny.geoserver.responses.wms.featureInfo;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import org.geotools.data.FeatureReader;
import org.geotools.data.FeatureResults;
import org.geotools.data.FeatureSource;
import org.geotools.data.Query;
import org.geotools.feature.AttributeType;
import org.geotools.feature.Feature;
import org.geotools.feature.FeatureType;
import org.geotools.feature.IllegalAttributeException;
import org.geotools.filter.AbstractFilter;
import org.geotools.filter.FilterFactory;
import org.geotools.filter.GeometryFilter;
import org.geotools.map.DefaultMapContext;
import org.geotools.map.DefaultMapLayer;
import org.geotools.map.MapContext;
import org.geotools.map.MapLayer;
import org.geotools.renderer.lite.LiteRenderer;
import org.geotools.styling.Style;
import org.vfny.geoserver.ServiceException;
import org.vfny.geoserver.WmsException;
import org.vfny.geoserver.global.FeatureTypeInfo;
import org.vfny.geoserver.global.GeoServer;
import org.vfny.geoserver.requests.wms.GetFeatureInfoRequest;


public abstract class AbstractFeatureInfoResponse extends GetFeatureInfoDelegate {

    /**
     * Creates a new GetMapDelegate object.
     */
    /** Autogenerated proxy constructor. */
    public AbstractFeatureInfoResponse() {
        super();
    }

    public abstract String getContentEncoding();

    /**
     * Evaluates if this Map producer can generate the map format specified by
     * <code>mapFormat</code>
     *
     * @param mapFormat the mime type of the output map format requiered
     *
     * @return true if class can produce a map in the passed format
     */
    public abstract boolean canProduce(String mapFormat);

    /**
     * Writes the image to the client.
     *
     * @param out The output stream to write to.
     *
     * @throws org.vfny.geoserver.ServiceException DOCUMENT ME!
     * @throws java.io.IOException DOCUMENT ME!
     */
    public abstract void writeTo(OutputStream out) throws ServiceException, IOException;
 
    /** A logger for this class. */
    protected static final Logger LOGGER = Logger.getLogger(
            "org.vfny.geoserver.responses.wms.featureinfo");

    /** The formats supported by this map delegate. */
    protected List supportedFormats = null;

    /** The image generated by the execute method. */
    protected List results;
    //private FeatureResults results;
    private LiteRenderer renderer;
    private Graphics2D graphic;

    /**
     * setted in execute() from the requested output format, it's holded just
     * to be sure that method has been called before getContentType() thus
     * supporting the workflow contract of the request processing
     */
    protected String format = null;

    /**
     * The formats this delegate supports. Includes those formats supported by
     * the Java ImageIO extension, mostly: <i>png, x-portable-graymap, jpeg,
     * jpeg2000, x-png, tiff, vnd.wap.wbmp, x-portable-pixmap,
     * x-portable-bitmap, bmp and x-portable-anymap</i>, but the specific ones
     * will depend on the platform and JAI version. At leas JPEG and PNG will
     * generally work.
     *
     * @return The list of the supported formats
     */
    public abstract List getSupportedFormats(); 

    /**
     * Halts the loading.  Right now just calls renderer.stopRendering.
     *
     * @param gs DOCUMENT ME!
     *
     * @task TODO: What would be nice is if we could also put the image being
     *       worked on in the GarbageCollector
     */
    public void abort(GeoServer gs) {
        renderer.stopRendering();

        //taking out for now, Andrea says it might have problems.
        //though this is in the abort, so do we really care if it throws
        //an exception?  Can it mess things up more than that?
        // if (graphic != null) {
        //   graphic.dispose();
        //}
    }

    /**
     * Gets the content type.  This is set by the request, should only be
     * called after execute.  GetMapResponse should handle this though.
     *
     * @param gs server configuration
     *
     * @return The mime type that this response will generate.
     *
     * @throws java.lang.IllegalStateException if <code>execute()</code> has
     *         not been previously called
     */
    public String getContentType(GeoServer gs)
        throws java.lang.IllegalStateException {
        //Return a default?  Format is not set until execute is called...
        return format;
    }

    /**
     * Performs the execute request using geotools rendering.
     *
     * @param requestedLayers The information on the types requested.
     * @param queries The results of the queries to generate maps with.
     * @param styles The styles to be used on the results.
     *
     * @throws WmsException For any problems.
     *
     * @task TODO: Update to feature streaming and latest api, Map is
     *       deprecated.
     */
    protected void execute(FeatureTypeInfo[] requestedLayers, Query[] queries,
        Style[] styles, int x, int y) throws WmsException {
        GetFeatureInfoRequest request = getRequest();
        this.format = request.getFormat();

        int width = request.getWidth();
        int height = request.getHeight();

        try {
            LOGGER.fine("setting up map");

            MapContext map = new DefaultMapContext();
            MapLayer layer = null;

            for (int i = 0; i < requestedLayers.length; i++) {
                Style style = styles[i];
                Query query = queries[i];
                FeatureSource source = requestedLayers[i].getFeatureSource();

                layer = new DefaultMapLayer(source, style);
                layer.setQuery(query);
                map.addLayer(layer);
            }

            LOGGER.fine("map setup");

            BufferedImage image = new BufferedImage(width, height,
                    BufferedImage.TYPE_INT_RGB);

            //LOGGER.fine("setting up renderer");
            //java.awt.Graphics g = image.getGraphics();
            graphic = image.createGraphics();
            graphic.setColor(request.getBgColor());

            if (!request.isTransparent()) {
                graphic.fillRect(0, 0, width, height);
            }

            renderer = new LiteRenderer(map);
            renderer.setOptimizedDataLoadingEnabled(true);

            //Envelope dataArea = map.getLayerBounds();
            Envelope dataArea = request.getBbox();
            Rectangle paintArea = new Rectangle(width, height);
            LOGGER.fine("dataArea is " + dataArea);
            
            renderer.setOutput(graphic, paintArea);
            LOGGER.fine("Output set");
            //renderer.paint((Graphics2D) image.getGraphics(), paintArea, at);
            
            Coordinate c = renderer.pixelToWorld(x, y, dataArea);
            LOGGER.fine("real world coordinate is " + c);
            FilterFactory filterFac = FilterFactory.createFilterFactory();
            GeometryFilter filter = filterFac.createGeometryFilter(AbstractFilter.GEOMETRY_WITHIN);
            GeometryFactory geomFac = new GeometryFactory();

            filter.addLeftGeometry(filterFac.createLiteralExpression(
            geomFac.createPoint(c)));
           
            int layerCount = map.getLayerCount();
            results = new ArrayList();
            for(int i=0; i < layerCount; i++){
                MapLayer ml = map.getLayer(i);
                FeatureResults match = ml.getFeatureSource().getFeatures(filter);
                if(match.getCount() > 0){
                    results.add(ml.getFeatureSource().getFeatures(filter));
                }
            }
            
            //results = layer.getFeatureSource().getFeatures(filter);
            
            LOGGER.fine("called renderer");

            map = null;
           
        } catch (Exception exp) {
            exp.printStackTrace();
            throw new WmsException(null, "Internal error : " + exp.getMessage());
        }
    }

    /**
     * Sets up the affine transform.  Stolen from liteRenderer code.
     *
     * @param mapExtent the map extent
     * @param screenSize the screen size
     *
     * @return a transform that maps from real world coordinates to the screen
     */
    public AffineTransform worldToScreenTransform(Envelope mapExtent,
        Rectangle screenSize) {
        double scaleX = screenSize.getWidth() / mapExtent.getWidth();
        double scaleY = screenSize.getHeight() / mapExtent.getHeight();

        double tx = -mapExtent.getMinX() * scaleX;
        double ty = (mapExtent.getMinY() * scaleY) + screenSize.getHeight();

        AffineTransform at = new AffineTransform(scaleX, 0.0d, 0.0d, -scaleY,
                tx, ty);

        return at;
    }

}
