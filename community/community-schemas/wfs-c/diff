Index: src/main/java/META-INF/services/org.geotools.util.ConverterFactory
===================================================================
--- src/main/java/META-INF/services/org.geotools.util.ConverterFactory	(revision 7645)
+++ src/main/java/META-INF/services/org.geotools.util.ConverterFactory	(working copy)
@@ -1 +0,0 @@
-org.geotools.util.AttributeConverterFactory
\ No newline at end of file
Index: src/main/java/org/geoserver/wfs/WFSLogger.java
===================================================================
--- src/main/java/org/geoserver/wfs/WFSLogger.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/WFSLogger.java	(working copy)
@@ -44,12 +44,11 @@
         Object result = invocation.proceed();
         log.append("\n\nResult:");
 
-        if (result instanceof EObject) {
-            log((EObject) result, 1, log);
-        } else {
-            log.append("\t" + result);
-        }
-
+        //        if (result instanceof EObject) {
+        //            log((EObject) result, 1, log);
+        //        } else {
+        //            log.append("\t" + result);
+        //        }
         logger.info(log.toString());
 
         return result;
Index: src/main/java/org/geoserver/wfs/WFSGetFeatureOutputFormat.java
===================================================================
--- src/main/java/org/geoserver/wfs/WFSGetFeatureOutputFormat.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/WFSGetFeatureOutputFormat.java	(working copy)
@@ -13,6 +13,8 @@
 import org.geoserver.platform.ServiceException;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.Set;
+import java.util.logging.Logger;
 
 
 /**
@@ -31,7 +33,12 @@
  *
  */
 public abstract class WFSGetFeatureOutputFormat extends Response {
+
     /**
+     * logger
+     */
+    protected static Logger LOGGER = Logger.getLogger("org.geoserver.wfs");
+    /**
      * Constructor which sets the outputFormat.
      *
      * @param outputFormat The well-known name of the format, not <code>null</code>
@@ -39,6 +46,15 @@
     public WFSGetFeatureOutputFormat(String outputFormat) {
         super(FeatureCollectionType.class, outputFormat);
     }
+    
+    /**
+     * Constructor which sets the outputFormats.
+     *
+     * @param outputFormats Set of well-known name of the format, not <code>null</code>
+     */
+    public WFSGetFeatureOutputFormat(Set outputFormats) {
+        super(FeatureCollectionType.class, outputFormats);
+    }
 
     /**
      * Returns the mime type <code>text/xml</code>.
@@ -58,7 +74,7 @@
      * Subclasses may implement
      * </p>
      */
-    public final boolean canHandle(Operation operation) {
+    public boolean canHandle(Operation operation) {
         //GetFeature operation?
         if ("GetFeature".equalsIgnoreCase(operation.getId())
                 || "GetFeatureWithLock".equalsIgnoreCase(operation.getId())) {
@@ -74,6 +90,29 @@
 
         return false;
     }
+    
+    /**
+     * capabilities output format string.  Something that's a valid XML element name.
+     * This should be overriden in each outputformat subclass, and if it's not a warning will be
+     * issued.
+     */
+    public /*abstract*/ String getCapabilitiesElementName() {
+        LOGGER.severe("ERROR IN " + this.getClass() + " IMPLEMENTATION.  getCapabilitiesElementName() should return a" + 
+                "valid XML element name string for use in the WFS 1.0.0 capabilities document.");
+        String of = getOutputFormat();
+        
+        //wfs 1.1 form is not a valid xml element, do a check
+        if (of.matches("(\\w)+")) {
+            return getOutputFormat();
+        } else {
+            String name = this.getClass().getName();
+            if ( name.indexOf('.') != -1 ) {
+                name = name.substring(name.lastIndexOf('.') + 1);
+            }
+            
+            return name;
+        }
+    }
 
     /**
      * Hook for subclasses to add addtional checks to {@link #canHandle(Operation)}.
Index: src/main/java/org/geoserver/wfs/WebFeatureService.java
===================================================================
--- src/main/java/org/geoserver/wfs/WebFeatureService.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/WebFeatureService.java	(working copy)
@@ -101,4 +101,14 @@
      */
     TransactionResponseType transaction(TransactionType request)
         throws WFSException;
+    
+    /**
+     * Release lock operation.
+     * <p>
+     * This is not an official operation of the spec.
+     * </p>
+     * @param lockId A prefiously held lock id.
+     */
+    void releaseLock(String lockId) throws WFSException;
+    
 }
Index: src/main/java/org/geoserver/wfs/CapabilitiesTransformer.java
===================================================================
--- src/main/java/org/geoserver/wfs/CapabilitiesTransformer.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/CapabilitiesTransformer.java	(working copy)
@@ -5,9 +5,14 @@
 package org.geoserver.wfs;
 
 import com.vividsolutions.jts.geom.Envelope;
+
+import net.opengis.wfs.GetCapabilitiesType;
+
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.ows.xml.v1_0.OWS;
 import org.geoserver.platform.GeoServerExtensions;
+import org.geoserver.wfs.response.GetCapabilitiesResponse;
 import org.geotools.factory.FactoryRegistry;
 import org.geotools.filter.FunctionExpression;
 import org.geotools.filter.v1_0.OGC;
@@ -18,15 +23,18 @@
 import org.opengis.filter.expression.Function;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
+import org.vfny.geoserver.global.FeatureTypeInfoTitleComparator;
 import org.vfny.geoserver.global.NameSpaceInfo;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.helpers.AttributesImpl;
 import java.io.IOException;
 import java.net.URL;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -99,11 +107,16 @@
         }
 
         class CapabilitiesTranslator1_0 extends TranslatorSupport {
+            GetCapabilitiesType request;
+            
             public CapabilitiesTranslator1_0(ContentHandler handler) {
                 super(handler, null, null);
             }
 
             public void encode(Object object) throws IllegalArgumentException {
+                request = (GetCapabilitiesType)object;
+                String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+                
                 AttributesImpl attributes = new AttributesImpl();
                 attributes.addAttribute("", "version", "version", "", "1.0.0");
                 attributes.addAttribute("", "xmlns", "xmlns", "", WFS_URI);
@@ -133,8 +146,8 @@
 
                 String locationAtt = XSI_PREFIX + ":schemaLocation";
                 String locationDef = WFS_URI + " "
-                    + ResponseUtils.appendPath(wfs.getSchemaBaseURL(),
-                        "wfs/1.0.0/WFS-capabilities.xsd");
+                    + ResponseUtils.appendPath(proxifiedBaseUrl,
+                        "schemas/wfs/1.0.0/WFS-capabilities.xsd");
                 attributes.addAttribute("", locationAtt, locationAtt, "", locationDef);
 
                 start("WFS_Capabilities", attributes);
@@ -174,8 +187,9 @@
 
                 handleKeywords(wfs.getKeywords());
 
-                URL or = wfs.getOnlineResource();
-                element("OnlineResource", (or == null) ? "" : or.toExternalForm());
+                String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+                
+                element("OnlineResource", ResponseUtils.appendPath(proxifiedBaseUrl, "wfs"));
                 element("Fees", wfs.getFees());
                 element("AccessConstraints", wfs.getAccessConstraints());
                 end("Service");
@@ -346,12 +360,12 @@
                     //FULL MONTY
                     Collection featureProducers = GeoServerExtensions.extensions(WFSGetFeatureOutputFormat.class);
 
+                    Map dupes = new HashMap();
                     for (Iterator i = featureProducers.iterator(); i.hasNext();) {
                         WFSGetFeatureOutputFormat format = (WFSGetFeatureOutputFormat) i.next();
-
-                        //wfs 1.1 form is not a valid xml element, do a check
-                        if (format.getOutputFormat().matches("(\\w)+")) {
-                            element(format.getOutputFormat(), null);
+                        if (!dupes.containsKey(format.getCapabilitiesElementName())) {
+                            element(format.getCapabilitiesElementName(), null);
+                            dupes.put(format.getCapabilitiesElementName(), new Object());
                         }
                     }
                 }
@@ -445,25 +459,23 @@
              *        requests
              */
             private void handleDcpType(String capabilityName, String httpMethod) {
-                String url = wfs.getOnlineResource().toString();
+                String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
 
-                if (url.endsWith("?")) {
-                    url = url.substring(0, url.length() - 1);
+                if (proxifiedBaseUrl.endsWith("?")) {
+                    proxifiedBaseUrl = proxifiedBaseUrl.substring(0, proxifiedBaseUrl.length() - 1);
                 }
 
                 if (HTTP_GET.equals(httpMethod)) {
-                    url += ("?request=" + capabilityName);
+                    proxifiedBaseUrl = ResponseUtils.appendPath(proxifiedBaseUrl, "wfs?request=" + capabilityName);
                 } else if (HTTP_POST.equals(httpMethod)) {
-                    url += "?";
-
-                    //url += ("/" + capabilityName + "?");
+                    proxifiedBaseUrl = ResponseUtils.appendPath(proxifiedBaseUrl, "wfs?");
                 }
 
                 start("DCPType");
                 start("HTTP");
 
                 AttributesImpl atts = new AttributesImpl();
-                atts.addAttribute("", "onlineResource", "onlineResource", "", url);
+                atts.addAttribute("", "onlineResource", "onlineResource", "", proxifiedBaseUrl);
                 element(httpMethod, null, atts);
 
                 end("HTTP");
@@ -515,8 +527,8 @@
 
                 end("Operations");
 
-                Collection featureTypes = catalog.getFeatureTypeInfos().values();
-
+                List featureTypes = new ArrayList(catalog.getFeatureTypeInfos().values());
+                Collections.sort(featureTypes, new FeatureTypeInfoTitleComparator());
                 for (Iterator it = featureTypes.iterator(); it.hasNext();) {
                     FeatureTypeInfo ftype = (FeatureTypeInfo) it.next();
 
@@ -731,11 +743,16 @@
         }
 
         class CapabilitiesTranslator1_1 extends TranslatorSupport {
+            GetCapabilitiesType request;
+            
             public CapabilitiesTranslator1_1(ContentHandler handler) {
                 super(handler, null, null);
             }
 
             public void encode(Object object) throws IllegalArgumentException {
+                request = (GetCapabilitiesType)object;
+                String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+                
                 AttributesImpl attributes = attributes(new String[] {
                             "version", "1.1.0", "xmlns:xsi", XSI_URI, "xmlns", WFS_URI, "xmlns:wfs",
                             WFS_URI, "xmlns:ows", OWS.NAMESPACE, "xmlns:gml", GML.NAMESPACE,
@@ -743,7 +760,7 @@
                             "xsi:schemaLocation",
                             
                         org.geoserver.wfs.xml.v1_1_0.WFS.NAMESPACE + " "
-                            + ResponseUtils.appendPath(wfs.getSchemaBaseURL(), "wfs/1.1.0/wfs.xsd")
+                            + ResponseUtils.appendPath(proxifiedBaseUrl, "schemas/wfs/1.1.0/wfs.xsd")
                         });
 
                 NameSpaceInfo[] namespaces = catalog.getNameSpaces();
@@ -1064,8 +1081,8 @@
 
                 end("Operations");
 
-                Collection featureTypes = catalog.getFeatureTypeInfos().values();
-
+                List featureTypes = new ArrayList(catalog.getFeatureTypeInfos().values());
+                Collections.sort(featureTypes, new FeatureTypeInfoTitleComparator());
                 for (Iterator i = featureTypes.iterator(); i.hasNext();) {
                     FeatureTypeInfo featureType = (FeatureTypeInfo) i.next();
                     featureType(featureType);
@@ -1180,8 +1197,15 @@
 
                 //TODO: other srs's
                 start("OutputFormats");
-                //TODO: process extension point
-                element("Format", "text/gml; subtype=gml/3.1.1");
+
+                Collection featureProducers = GeoServerExtensions.extensions(WFSGetFeatureOutputFormat.class);
+                for (Iterator i = featureProducers.iterator(); i.hasNext();) {
+                    WFSGetFeatureOutputFormat format = (WFSGetFeatureOutputFormat) i.next();
+                    for ( Iterator f = format.getOutputFormats().iterator(); f.hasNext(); ) {
+                        element( "Format", f.next().toString() );
+                    }
+                }
+                    
                 end("OutputFormats");
 
                 Envelope bbox = null;
@@ -1429,29 +1453,22 @@
                 start("ows:DCP");
                 start("ows:HTTP");
 
-                String url = wfs.getOnlineResource().toString();
+                String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
 
-                if (url.indexOf('?') != -1) {
-                    url = url.substring(0, url.indexOf('?'));
+                if (proxifiedBaseUrl.endsWith("?")) {
+                    proxifiedBaseUrl = proxifiedBaseUrl.substring(0, proxifiedBaseUrl.length() - 1);
                 }
 
+                if (proxifiedBaseUrl.indexOf('?') != -1) {
+                    proxifiedBaseUrl = proxifiedBaseUrl.substring(0, proxifiedBaseUrl.indexOf('?'));
+                }
+
                 if (get) {
-                    //    				String getURL = wfs.getOnlineResource().toString();
-                    //    				if ( getURL.indexOf( '?' ) == -1 ) {
-                    //    					getURL += "?";
-                    //    				}
-                    //    				else {
-                    //    					getURL = getURL.endsWith( "?" ) ? getURL : getURL + "&";
-                    //    				}
-                    element("ows:Get", null, attributes(new String[] { "xlink:href", url }));
+                    element("ows:Get", null, attributes(new String[] { "xlink:href", ResponseUtils.appendPath(proxifiedBaseUrl, "wfs?") }));
                 }
 
                 if (post) {
-                    //    				String postURL = wfs.getOnlineResource().toString();
-                    //    				if ( postURL.indexOf( '?' ) != -1 ) {
-                    //    					postURL = postURL.substring( 0, postURL.indexOf( '?' ) );
-                    //    				}
-                    element("ows:Post", null, attributes(new String[] { "xlink:href", url }));
+                    element("ows:Post", null, attributes(new String[] { "xlink:href", ResponseUtils.appendPath(proxifiedBaseUrl, "wfs?") }));
                 }
 
                 end("ows:HTTP");
Index: src/main/java/org/geoserver/wfs/response/HitsOutputFormat.java
===================================================================
--- src/main/java/org/geoserver/wfs/response/HitsOutputFormat.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/response/HitsOutputFormat.java	(working copy)
@@ -60,7 +60,7 @@
         GetFeatureType request = (GetFeatureType) OwsUtils.parameter(operation.getParameters(),
                 GetFeatureType.class);
 
-        return request.getResultType() == ResultTypeType.HITS_LITERAL;
+        return (request != null) && (request.getResultType() == ResultTypeType.HITS_LITERAL);
     }
 
     public void write(Object value, OutputStream output, Operation operation)
Index: src/main/java/org/geoserver/wfs/response/TransactionResponse.java
===================================================================
--- src/main/java/org/geoserver/wfs/response/TransactionResponse.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/response/TransactionResponse.java	(working copy)
@@ -5,11 +5,15 @@
 package org.geoserver.wfs.response;
 
 import net.opengis.wfs.ActionType;
+import net.opengis.wfs.GetFeatureType;
 import net.opengis.wfs.InsertResultsType;
 import net.opengis.wfs.InsertedFeatureType;
 import net.opengis.wfs.TransactionResponseType;
 import net.opengis.wfs.TransactionResultsType;
+import net.opengis.wfs.TransactionType;
+
 import org.geoserver.ows.Response;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
@@ -54,13 +58,13 @@
         TransactionResponseType response = (TransactionResponseType) value;
 
         if (new Version("1.0.0").equals(operation.getService().getVersion())) {
-            v_1_0(response, output);
+            v_1_0(response, output, operation);
         } else {
-            v_1_1(response, output);
+            v_1_1(response, output, operation);
         }
     }
 
-    public void v_1_0(TransactionResponseType response, OutputStream output)
+    public void v_1_0(TransactionResponseType response, OutputStream output, Operation operation)
         throws IOException, ServiceException {
         TransactionResultsType result = response.getTransactionResults();
 
@@ -87,8 +91,11 @@
         writer.write(indent);
         writer.write("xsi:schemaLocation=\"http://www.opengis.net/wfs ");
 
-        String baseUrl = ResponseUtils.appendPath(wfs.getSchemaBaseURL(),
-                "wfs/1.0.0/WFS-transaction.xsd");
+        TransactionType req = (TransactionType)operation.getParameters()[0];
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(req.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+        
+        String baseUrl = ResponseUtils.appendPath(proxifiedBaseUrl,
+                "schemas/wfs/1.0.0/WFS-transaction.xsd");
 
         writer.write(baseUrl);
         writer.write("\">");
@@ -178,7 +185,7 @@
         writer.flush();
     }
 
-    public void v_1_1(TransactionResponseType response, OutputStream output)
+    public void v_1_1(TransactionResponseType response, OutputStream output, Operation operation)
         throws IOException, ServiceException {
         if (!response.getTransactionResults().getAction().isEmpty()) {
             //since we do atomic transactions, an action failure means all we rolled back
@@ -190,8 +197,11 @@
 
         Encoder encoder = new Encoder(configuration, configuration.schema());
 
+        TransactionType req = (TransactionType)operation.getParameters()[0];
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(req.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+        
         encoder.setSchemaLocation(org.geoserver.wfs.xml.v1_1_0.WFS.NAMESPACE,
-            ResponseUtils.appendPath(wfs.getSchemaBaseURL(), "wfs/1.1.0/wfs.xsd"));
+            ResponseUtils.appendPath(proxifiedBaseUrl, "schemas/wfs/1.1.0/wfs.xsd"));
 
         try {
             encoder.encode(response, org.geoserver.wfs.xml.v1_1_0.WFS.TRANSACTIONRESPONSE, output);
Index: src/main/java/org/geoserver/wfs/response/LockFeatureTypeResponse.java
===================================================================
--- src/main/java/org/geoserver/wfs/response/LockFeatureTypeResponse.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/response/LockFeatureTypeResponse.java	(working copy)
@@ -4,8 +4,13 @@
  */
 package org.geoserver.wfs.response;
 
+import net.opengis.wfs.GetFeatureType;
 import net.opengis.wfs.LockFeatureResponseType;
+import net.opengis.wfs.LockFeatureType;
+import net.opengis.wfs.TransactionType;
+
 import org.geoserver.ows.Response;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
@@ -54,6 +59,9 @@
         String indent = wfs.isVerbose() ? "   " : "";
         BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output));
 
+        LockFeatureType lft = (LockFeatureType)operation.getParameters()[0];
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(lft.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+        
         //TODO: get rid of this hardcoding, and make a common utility to get all
         //these namespace imports, as everyone is using them, and changes should
         //go through to all the operations.
@@ -64,8 +72,8 @@
 
         writer.write(indent + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " + "\n");
         writer.write(indent + "xsi:schemaLocation=\"http://www.opengis.net/wfs ");
-        writer.write(ResponseUtils.appendPath(wfs.getSchemaBaseURL(),
-                "wfs/1.0.0/WFS-transaction.xsd"));
+        writer.write(ResponseUtils.appendPath(proxifiedBaseUrl,
+                "schemas/wfs/1.0.0/WFS-transaction.xsd"));
         writer.write("\">" + "\n");
 
         writer.write(indent + "<LockId>" + lockResponse.getLockId() + "</LockId>" + "\n");
@@ -115,6 +123,12 @@
     void write1_1(LockFeatureResponseType lockResponse, OutputStream output, Operation operation)
         throws IOException {
         Encoder encoder = new Encoder(configuration, configuration.schema());
+        
+        LockFeatureType req = (LockFeatureType)operation.getParameters()[0];
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(req.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+        
+        encoder.setSchemaLocation(org.geoserver.wfs.xml.v1_1_0.WFS.NAMESPACE,
+                ResponseUtils.appendPath(proxifiedBaseUrl, "schemas/wfs/1.1.0/wfs.xsd"));
 
         try {
             encoder.encode(lockResponse, org.geoserver.wfs.xml.v1_1_0.WFS.LOCKFEATURERESPONSE,
Index: src/main/java/org/geoserver/wfs/response/GetCapabilitiesResponse.java
===================================================================
--- src/main/java/org/geoserver/wfs/response/GetCapabilitiesResponse.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/response/GetCapabilitiesResponse.java	(working copy)
@@ -47,7 +47,7 @@
         TransformerBase tx = (TransformerBase) value;
 
         try {
-            tx.transform(this, output);
+            tx.transform(operation.getParameters()[0], output);
         } catch (TransformerException e) {
             throw (IOException) new IOException().initCause(e);
         }
Index: src/main/java/org/geoserver/wfs/response/WfsExceptionHandler.java
===================================================================
--- src/main/java/org/geoserver/wfs/response/WfsExceptionHandler.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/response/WfsExceptionHandler.java	(working copy)
@@ -45,6 +45,7 @@
         HttpServletRequest request, HttpServletResponse response) {
         Version version = service.getVersion();
 
+        verboseExceptions = wfs.getGeoServer().isVerboseExceptions();
         if (new Version("1.0.0").equals(version)) {
             handle1_0(e, response);
         } else {
@@ -79,14 +80,17 @@
 
             s.append(">");
 
-            if ((e.getMessage() != null) && !e.getMessage().equals("")) {
+            if (e.getMessage() != null) {
                 s.append("\n" + tab + tab);
-                s.append(ResponseUtils.encodeXML(e.getMessage()));
+                dumpExceptionMessages(e, s);
 
-                ByteArrayOutputStream stackTrace = new ByteArrayOutputStream();
-                e.printStackTrace(new PrintStream(stackTrace));
+                if(verboseExceptions) {
+                  ByteArrayOutputStream stackTrace = new ByteArrayOutputStream();
+                  e.printStackTrace(new PrintStream(stackTrace));
 
-                s.append(ResponseUtils.encodeXML(new String(stackTrace.toByteArray())));
+                  s.append("\nDetails:\n");
+                  s.append(ResponseUtils.encodeXML(new String(stackTrace.toByteArray())));
+                }
             }
 
             s.append("\n</ServiceException>");
Index: src/main/java/org/geoserver/wfs/DefaultWebFeatureService.java
===================================================================
--- src/main/java/org/geoserver/wfs/DefaultWebFeatureService.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/DefaultWebFeatureService.java	(working copy)
@@ -15,6 +15,9 @@
 import net.opengis.wfs.TransactionType;
 import org.geotools.xml.transform.TransformerBase;
 import org.opengis.filter.FilterFactory;
+import org.springframework.beans.BeansException;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.ApplicationContextAware;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 
@@ -25,22 +28,28 @@
  * @author Justin Deoliveira, The Open Planning Project
  *
  */
-public class DefaultWebFeatureService implements WebFeatureService {
+public class DefaultWebFeatureService implements WebFeatureService, ApplicationContextAware {
     /**
      * WFS service configuration.
      */
-    WFS wfs;
+    protected WFS wfs;
 
     /**
      * The catalog
      */
-    Data catalog;
+    protected Data catalog;
 
     /**
      * Filter factory
      */
-    FilterFactory filterFactory;
+    protected FilterFactory filterFactory;
 
+    /**
+     * The spring application context, used to look up transaction listeners, plugins and
+     * element handlers
+     */
+    protected ApplicationContext context;
+
     public DefaultWebFeatureService(WFS wfs, Data catalog) {
         this.wfs = wfs;
         this.catalog = catalog;
@@ -141,7 +150,7 @@
      */
     public TransactionResponseType transaction(TransactionType request)
         throws WFSException {
-        Transaction transaction = new Transaction(wfs, catalog);
+        Transaction transaction = new Transaction(wfs, catalog, context);
         transaction.setFilterFactory(filterFactory);
 
         return transaction.transaction(request);
@@ -155,4 +164,9 @@
     public void releaseAllLocks() throws WFSException {
         new LockFeature(wfs, catalog).releaseAll();
     }
+
+    public void setApplicationContext(ApplicationContext context)
+        throws BeansException {
+        this.context = context;
+    }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/PropertyTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/PropertyTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/PropertyTypeBinding.java	(working copy)
@@ -100,16 +100,25 @@
 
         //&lt;xsd:element minOccurs="0" name="Value"&gt;
         if (node.hasChild("Value")) {
-            Map map = (Map) node.getChildValue("Value");
+            Object object = node.getChildValue("Value");
 
-            if (!map.isEmpty()) {
-                //first check for some text
-                if (map.containsKey(null)) {
-                    property.setValue(map.get(null));
-                } else {
-                    //perhaps some other value
-                    property.setValue(map.values().iterator().next());
+            //check for a map
+            if (object instanceof Map) {
+                Map map = (Map) object;
+
+                //this means a complex element parsed by xs:AnyType binding
+                // try to pull out some text
+                if (!map.isEmpty()) {
+                    //first check for some text
+                    if (map.containsKey(null)) {
+                        property.setValue(map.get(null));
+                    } else {
+                        //perhaps some other value
+                        property.setValue(map.values().iterator().next());
+                    }
                 }
+            } else {
+                property.setValue(object);
             }
         }
 
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/QueryTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/QueryTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/QueryTypeBinding.java	(working copy)
@@ -12,6 +12,8 @@
 import org.opengis.filter.Filter;
 import org.opengis.filter.expression.PropertyName;
 import org.xml.sax.helpers.NamespaceSupport;
+
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -147,7 +149,7 @@
         Filter filter = (Filter) node.getChildValue(Filter.class);
 
         if (filter == null) {
-            filter = (Filter) org.geotools.filter.Filter.NONE;
+            filter = (Filter) Filter.INCLUDE;
         }
 
         queryType.setFilter(filter);
@@ -163,6 +165,13 @@
         //<xsd:attribute name="featureVersion" type="xsd:string" use="optional">  
         queryType.setFeatureVersion((String) node.getAttributeValue("featureVersion"));
 
+        //JD: even though reprojection is not supported in 1.0 we handle it 
+        // anyways
+        //&lt;xsd:attribute name="srsName" type="xsd:anyURI" use="optional"&gt;
+        if (node.hasAttribute("srsName")) {
+            queryType.setSrsName(new URI((String)node.getAttributeValue("srsName")));
+        }
+
         return queryType;
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/WfsXmlReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/WfsXmlReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/WfsXmlReader.java	(working copy)
@@ -22,7 +22,7 @@
         this.configuration = configuration;
     }
 
-    public Object read(Object object, Reader reader) throws Exception {
+    public Object read(Object request, Reader reader) throws Exception {
         Parser parser = new Parser(configuration);
 
         return parser.parse(reader);
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/InsertElementTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/InsertElementTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/InsertElementTypeBinding.java	(working copy)
@@ -4,12 +4,20 @@
  */
 package org.geoserver.wfs.xml.v1_0_0;
 
+import java.net.URI;
+
 import net.opengis.wfs.InsertElementType;
 import net.opengis.wfs.WfsFactory;
+
+import org.geoserver.wfs.WFSException;
 import org.geotools.feature.Feature;
+import org.geotools.gml2.bindings.GML2ParsingUtils;
 import org.geotools.xml.AbstractComplexBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
+import org.picocontainer.MutablePicoContainer;
+
 import javax.xml.namespace.QName;
 
 
@@ -56,6 +64,22 @@
         return InsertElementTypeBinding.class;
     }
 
+    public void initializeChildContext(ElementInstance childInstance,
+            Node node, MutablePicoContainer context) {
+        //if an srsName is set for this geometry, put it in the context for 
+        // children, so they can use it as well
+        if ( node.hasAttribute("srsName") ) {
+            try {
+                CoordinateReferenceSystem crs = GML2ParsingUtils.crs(node);
+                if ( crs != null ) {
+                    context.registerComponentInstance(CoordinateReferenceSystem.class, crs);
+                }
+            } catch(Exception e) {
+                throw new WFSException(e, "InvalidParameterValue");
+            }
+        }
+    }
+    
     /**
      * <!-- begin-user-doc -->
      * <!-- end-user-doc -->
@@ -74,6 +98,14 @@
             insertElement.setHandle((String) node.getAttributeValue("handle"));
         }
 
+        //NOTE: officially this is not supported for wfs 1.0, but we support it
+        // here as an extension to wfs 1.0, also since its not actualy in the 
+        // schema it comes to us as a string, not a uri
+        //&lt;xsd:attribute name="srsName" type="xsd:anyURI" use="optional"&gt;
+        if (node.hasAttribute("srsName")) {
+            String srsName = (String) node.getAttributeValue("srsName");
+            insertElement.setSrsName(new URI(srsName));
+        }
         return insertElement;
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/XmlSchemaEncoder.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/XmlSchemaEncoder.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/XmlSchemaEncoder.java	(working copy)
@@ -4,6 +4,9 @@
  */
 package org.geoserver.wfs.xml.v1_0_0;
 
+import net.opengis.wfs.DescribeFeatureTypeType;
+
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
@@ -22,6 +25,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.xml.transform.TransformerException;
 
@@ -60,7 +64,7 @@
     protected void write(FeatureTypeInfo[] featureTypeInfos, OutputStream output,
         Operation describeFeatureType) throws IOException {
         //generates response, using general function
-        String xmlResponse = generateTypes(featureTypeInfos);
+        String xmlResponse = generateTypes(featureTypeInfos, (DescribeFeatureTypeType) describeFeatureType.getParameters()[0]);
 
         if (!wfs.isVerbose()) {
             //strip out the formatting.  This is pretty much the only way we
@@ -86,7 +90,7 @@
     *
     * @throws WFSException For any problems.
     */
-    private final String generateTypes(FeatureTypeInfo[] infos)
+    private final String generateTypes(FeatureTypeInfo[] infos, DescribeFeatureTypeType request)
         throws IOException {
         // Initialize return information and intermediate return objects
         StringBuffer tempResponse = new StringBuffer();
@@ -94,6 +98,7 @@
         tempResponse.append("<?xml version=\"1.0\" encoding=\"" + wfs.getCharSet().displayName()
             + "\"?>" + "\n<xs:schema ");
 
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(request.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
         //allSameType will throw WFSException if there are types that are not found.
         if (allSameType(infos)) {
             //all the requested have the same namespace prefix, so return their
@@ -124,9 +129,8 @@
             //            tempResponse.append("\n\n<xs:import namespace=" + GML_URL
             //                + " schemaLocation=\"" + request.getSchemaBaseUrl()
             //                + "gml/2.1.2/feature.xsd\"/>\n\n");
-            tempResponse.append("\n\n<xs:import namespace=" + GML_URL + " schemaLocation=\""
-                + ResponseUtils.appendPath(wfs.getSchemaBaseURL(), "gml/2.1.2/feature.xsd")
-                + "\"/>\n\n");
+            tempResponse.append("\n\n<xs:import namespace=" + GML_URL + " schemaLocation=\"" +
+            		ResponseUtils.appendPath(proxifiedBaseUrl, "schemas/gml/2.1.2.1/feature.xsd") + "\"/>\n\n");
             tempResponse.append(generateSpecifiedTypes(infos));
         } else {
             //the featureTypes do not have all the same prefixes.
@@ -146,7 +150,7 @@
             while (prefixIter.hasNext()) {
                 //iterate through prefixes, and add the types that have that prefix.
                 String prefix = prefixIter.next().toString();
-                tempResponse.append(getNSImport(prefix, infos));
+                tempResponse.append(getNSImport(prefix, infos, proxifiedBaseUrl));
             }
         }
 
@@ -169,14 +173,14 @@
      *
      * @return The namespace element.
      */
-    private StringBuffer getNSImport(String prefix, FeatureTypeInfo[] infos) {
+    private StringBuffer getNSImport(String prefix, FeatureTypeInfo[] infos, String baseUrl) {
         LOGGER.finer("prefix is " + prefix);
 
         StringBuffer retBuffer = new StringBuffer("\n  <xs:import namespace=\"");
         String namespace = catalog.getNameSpace(prefix).getURI();
         retBuffer.append(namespace + "\"");
-        retBuffer.append("\n        schemaLocation=\"" + wfs.getOnlineResource().toString()
-            + "?request=DescribeFeatureType&amp;typeName=");
+        retBuffer.append("\n        schemaLocation=\"" + baseUrl
+            + "?request=DescribeFeatureType&amp;service=wfs&amp;version=1.0.0&amp;typeName=");
 
         for (int i = 0; i < infos.length; i++) {
             FeatureTypeInfo info = infos[i];
@@ -301,7 +305,7 @@
 
             return writer.getBuffer().toString();
         } catch (TransformerException te) {
-            LOGGER.warning(te.toString());
+            LOGGER.log( Level.WARNING, "Error generating schema from feature type", te );
             throw (IOException) new IOException("problem transforming type").initCause(te);
         }
     }
Index: src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java	(working copy)
@@ -4,25 +4,38 @@
  */
 package org.geoserver.wfs.xml.v1_0_0;
 
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
+
 import net.opengis.ows.OwsFactory;
 import net.opengis.wfs.WfsFactory;
 import org.eclipse.xsd.util.XSDSchemaLocationResolver;
 import org.geoserver.wfs.xml.FeatureTypeSchemaBuilder;
 import org.geoserver.wfs.xml.WFSHandlerFactory;
+import org.geoserver.wfs.xml.gml3.AbstractGeometryTypeBinding;
+import org.geotools.feature.FeatureType;
 import org.geotools.filter.v1_0.OGCConfiguration;
+import org.geotools.gml2.FeatureTypeCache;
 import org.geotools.gml2.GMLConfiguration;
 import org.geotools.gml2.bindings.GML;
 import org.geotools.xml.BindingConfiguration;
 import org.geotools.xml.Configuration;
+import org.geotools.xml.OptionalComponentParameter;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.picocontainer.MutablePicoContainer;
+import org.picocontainer.Parameter;
+import org.picocontainer.defaults.SetterInjectionComponentAdapter;
 import org.vfny.geoserver.global.Data;
+import org.vfny.geoserver.global.FeatureTypeInfo;
+import org.vfny.geoserver.global.GeoServer;
 
 
 /**
  * Parser configuration for wfs 1.0.
  *
  * @author Justin Deoliveira, The Open Planning Project
- *
+ * TODO: this class duplicates a lot of what is is in the 1.1 configuration, merge them
  */
 public class WFSConfiguration extends Configuration {
     Data catalog;
@@ -34,6 +47,15 @@
         this.catalog = catalog;
         this.schemaBuilder = schemaBuilder;
 
+        catalog.getGeoServer().addListener(
+            new GeoServer.Listener() {
+    
+              public void changed() {
+                  flush();
+              }
+            }
+          );
+        
         addDependency(new OGCConfiguration());
         addDependency(new GMLConfiguration());
     }
@@ -62,6 +84,24 @@
         context.registerComponentInstance(WfsFactory.eINSTANCE);
         context.registerComponentInstance(new WFSHandlerFactory(catalog, schemaBuilder));
         context.registerComponentInstance(catalog);
+        
+        //TODO: this code is copied from the 1.1 configuration, FACTOR IT OUT!!!
+        //seed the cache with entries from the catalog
+        FeatureTypeCache featureTypeCache = (FeatureTypeCache) context
+            .getComponentInstanceOfType(FeatureTypeCache.class);
+
+        try {
+            Collection featureTypes = catalog.getFeatureTypeInfos().values();
+
+            for (Iterator f = featureTypes.iterator(); f.hasNext();) {
+                FeatureTypeInfo meta = (FeatureTypeInfo) f.next();
+                FeatureType featureType = meta.getFeatureType();
+
+                featureTypeCache.put(featureType);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     protected void configureBindings(MutablePicoContainer bindings) {
@@ -70,5 +110,18 @@
         //override the GMLAbstractFeatureTypeBinding
         bindings.registerComponentImplementation(GML.AbstractFeatureType,
             GMLAbstractFeatureTypeBinding.class);
+        
+        //use setter injection for AbstractGeometryType bindign to allow an 
+        // optional crs to be set in teh binding context for parsing, this crs
+        // is set by the binding of a parent element.
+        // note: it is important that this component adapter is non-caching so 
+        // that the setter property gets updated properly every time
+        bindings.registerComponent(
+            new SetterInjectionComponentAdapter( 
+                GML.AbstractGeometryType, AbstractGeometryTypeBinding.class, 
+                new Parameter[]{ new OptionalComponentParameter(CoordinateReferenceSystem.class)} 
+            )
+        );
+        
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocator.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocator.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocator.java	(working copy)
@@ -4,27 +4,18 @@
  */
 package org.geoserver.wfs.xml.v1_1_0;
 
-import org.eclipse.xsd.XSDElementDeclaration;
 import org.eclipse.xsd.XSDSchema;
 import org.geoserver.wfs.xml.FeatureTypeSchemaBuilder;
-import org.geotools.data.DataStore;
-import org.geotools.data.FeatureSource;
-import org.geotools.data.feature.FeatureAccess;
-import org.geotools.data.feature.FeatureSource2;
 import org.geotools.xml.Configuration;
 import org.geotools.xml.SchemaLocator;
-import org.opengis.feature.type.AttributeDescriptor;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.Map;
-import java.util.Map.Entry;
 
 
 /**
- * Schema locator which adds types defined in applications schemas to the wfs
- * schema proper.
+ * Schema locator which adds types defined in applications schemas to the wfs schema proper.
  *
  * @author Justin Deoliveira, The Open Planning Project
  *
@@ -44,53 +35,37 @@
     }
 
     protected XSDSchema createSchema() throws Exception {
+        return createSchema(null);
+    }
+    
+    /**
+     * Creates the schema using this SchemaLocator.  Note that in order to locate
+     * schemas, you need to know *where* the schemas are, and they might be
+     * in different places, depending on who's calling the server.  Thus the 
+     * baseUrl parameter.
+     * @param baseUrl If this parameter is not null, its value will be used as the starting
+     * point for figuring out the baseUrl for any schemas built with this class.
+     * @return
+     * @throws Exception
+     */
+    protected XSDSchema createSchema(String baseUrl) throws Exception {
         XSDSchema wfsSchema = super.createSchema();
 
-        // incorporate application schemas into the wfs schema
+        //incorporate application schemas into the wfs schema
         Collection featureTypeInfos = catalog.getFeatureTypeInfos().values();
 
         for (Iterator i = featureTypeInfos.iterator(); i.hasNext();) {
-            XSDSchema schema = null;
-
             FeatureTypeInfo meta = (FeatureTypeInfo) i.next();
 
-            // we get a geoserver feature source wrapper so it is not
-            // enough to check for featureSource instanceof FeatureSource2
-            DataStore dataStore = meta.getDataStoreInfo().getDataStore();
+            //build the schema for the types in the single namespace
+            XSDSchema schema = schemaBuilder.build(new FeatureTypeInfo[] { meta }, baseUrl);
 
-            if (dataStore instanceof FeatureAccess) {
-                String name = meta.getTypeName();
-                FeatureSource2 source = (FeatureSource2) dataStore.getFeatureSource(name);
-                AttributeDescriptor descriptor = (AttributeDescriptor) source.describe();
-                XSDElementDeclaration elemDecl = (XSDElementDeclaration) descriptor.getUserData(XSDElementDeclaration.class);
-
-                if (elemDecl != null) {
-                    schema = elemDecl.getSchema();
-                }
-            }
-
-            if (schema == null) {
-                // build the schema for the types in the single namespace
-                schema = schemaBuilder.build(new FeatureTypeInfo[] { meta });
-            }
-
-            // declare the namespace
+            //declare the namespace
             String prefix = meta.getNameSpace().getPrefix();
             String namespaceURI = meta.getNameSpace().getURI();
-            Map namePrefixToNamespaceMap = wfsSchema.getQNamePrefixToNamespaceMap();
-            namePrefixToNamespaceMap.put(prefix, namespaceURI);
+            wfsSchema.getQNamePrefixToNamespaceMap().put(prefix, namespaceURI);
 
-            Map schemaPrefixes = schema.getQNamePrefixToNamespaceMap();
-
-            for (Iterator it = schemaPrefixes.entrySet().iterator(); it.hasNext();) {
-                Map.Entry entry = (Entry) it.next();
-
-                if (!namePrefixToNamespaceMap.containsKey(entry.getKey())) {
-                    namePrefixToNamespaceMap.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            // add the types + elements to the wfs schema
+            //add the types + elements to the wfs schema
             for (Iterator t = schema.getTypeDefinitions().iterator(); t.hasNext();) {
                 wfsSchema.getTypeDefinitions().add(t.next());
             }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/Base_TypeNameListTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/Base_TypeNameListTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/Base_TypeNameListTypeBinding.java	(working copy)
@@ -58,6 +58,7 @@
      */
     public Object parse(InstanceComponent instance, Object value)
         throws Exception {
-        return value;
+        //TODO: implement
+        return null;
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/DeleteElementTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/DeleteElementTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/DeleteElementTypeBinding.java	(working copy)
@@ -6,7 +6,9 @@
 
 import net.opengis.wfs.DeleteElementType;
 import net.opengis.wfs.WfsFactory;
-import org.geotools.xml.AbstractComplexBinding;
+import org.eclipse.emf.ecore.EObject;
+import org.eclipse.emf.ecore.EStructuralFeature;
+import org.geotools.xml.AbstractComplexEMFBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
 import org.opengis.filter.Filter;
@@ -72,7 +74,7 @@
  *
  * @generated
  */
-public class DeleteElementTypeBinding extends AbstractComplexBinding {
+public class DeleteElementTypeBinding extends AbstractComplexEMFBinding {
     WfsFactory wfsfactory;
 
     public DeleteElementTypeBinding(WfsFactory wfsfactory) {
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/PropertyTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/PropertyTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/PropertyTypeBinding.java	(working copy)
@@ -6,9 +6,23 @@
 
 import net.opengis.wfs.PropertyType;
 import net.opengis.wfs.WfsFactory;
+import org.geoserver.platform.GeoServerExtensions;
+import org.geoserver.wfs.xml.GML3Profile;
+import org.geoserver.wfs.xml.PropertyTypePropertyExtractor;
+import org.geoserver.wfs.xml.TypeMappingProfile;
+import org.geoserver.wfs.xml.XSProfile;
 import org.geotools.xml.AbstractComplexBinding;
+import org.geotools.xml.AbstractComplexEMFBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
+import org.geotools.xs.bindings.XS;
+import org.opengis.feature.type.Name;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import javax.xml.namespace.QName;
 
@@ -78,6 +92,8 @@
      */
     public Object parse(ElementInstance instance, Node node, Object value)
         throws Exception {
+        //TODO: much of this method is duplicated in the 1.1.0 binding, it 
+        // would be nice if we could sync them up somewhow....
         PropertyType property = wfsfactory.createPropertyType();
 
         //&lt;xsd:element name="Name" type="xsd:QName"&gt;
@@ -85,19 +101,37 @@
 
         //&lt;xsd:element minOccurs="0" name="Value"&gt;
         if (node.hasChild("Value")) {
-            Map map = (Map) node.getChildValue("Value");
+            Object object = node.getChildValue("Value");
 
-            if (!map.isEmpty()) {
-                //first check for some text
-                if (map.containsKey(null)) {
-                    property.setValue(map.get(null));
-                } else {
-                    //perhaps some other value
-                    property.setValue(map.values().iterator().next());
+            //check for a map
+            if (object instanceof Map) {
+                Map map = (Map) object;
+
+                //this means a complex element parsed by xs:AnyType binding
+                // try to pull out some text
+                if (!map.isEmpty()) {
+                    //first check for some text
+                    if (map.containsKey(null)) {
+                        property.setValue(map.get(null));
+                    } else {
+                        //perhaps some other value
+                        property.setValue(map.values().iterator().next());
+                    }
                 }
+            } else {
+                property.setValue(object);
             }
         }
 
         return property;
     }
+
+    /**
+     * This method does nothing, its functionality is implemented by
+     * {@link PropertyTypePropertyExtractor}.
+     */
+    public Object getProperty(Object object, QName name)
+        throws Exception {
+        return null;
+    }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSBindingConfiguration.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSBindingConfiguration.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSBindingConfiguration.java	(working copy)
@@ -13,7 +13,7 @@
  *
  * @generated
  */
-public final class WFSBindingConfiguration implements BindingConfiguration {
+public class WFSBindingConfiguration implements BindingConfiguration {
     /**
      * @generated modifiable
      */
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocationResolver.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocationResolver.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSSchemaLocationResolver.java	(working copy)
@@ -22,7 +22,7 @@
 
         if ("http://www.opengis.net/wfs".equals(namespaceURI) && (schemaLocationURI != null)) {
             if (schemaLocationURI.endsWith("wfs.xsd")) {
-                return getClass().getResource("wfs.xsd").toString();
+                return WFSSchemaLocationResolver.class.getResource("wfs.xsd").toString();
             }
         }
 
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/QueryTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/QueryTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/QueryTypeBinding.java	(working copy)
@@ -9,7 +9,10 @@
 import org.geotools.xml.AbstractComplexBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
+import org.opengis.feature.Property;
 import org.opengis.filter.Filter;
+import org.opengis.filter.expression.Literal;
+import org.opengis.filter.expression.PropertyName;
 import org.opengis.filter.sort.SortBy;
 import java.net.URI;
 import java.util.Iterator;
@@ -189,7 +192,12 @@
         if (node.hasChild("PropertyName")) {
             //HACK, stripping of namespace prefix
             for (Iterator p = node.getChildValues("PropertyName").iterator(); p.hasNext();) {
-                String propertyName = (String) p.next();
+                Object property = p.next();
+                String propertyName;
+                if(property instanceof String)
+                    propertyName = (String) property;
+                else
+                    propertyName = (String) ((PropertyName) property).getPropertyName();
 
                 if (propertyName.indexOf(':') != -1) {
                     propertyName = propertyName.substring(propertyName.indexOf(':') + 1);
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/WfsXmlReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/WfsXmlReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/WfsXmlReader.java	(working copy)
@@ -34,7 +34,7 @@
         this.configuration = configuration;
     }
 
-    public Object read(Object object, Reader reader) throws Exception {
+    public Object read(Object request, Reader reader) throws Exception {
         //TODO: make this configurable?
         configuration.getProperties().add(Parser.Properties.PARSE_UNKNOWN_ELEMENTS);
 
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/InsertElementTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/InsertElementTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/InsertElementTypeBinding.java	(working copy)
@@ -7,11 +7,18 @@
 import net.opengis.wfs.IdentifierGenerationOptionType;
 import net.opengis.wfs.InsertElementType;
 import net.opengis.wfs.WfsFactory;
+
+import org.geoserver.wfs.WFSException;
 import org.geotools.feature.Feature;
 import org.geotools.feature.FeatureCollection;
-import org.geotools.xml.AbstractComplexBinding;
+import org.geotools.gml2.bindings.GML2ParsingUtils;
+import org.geotools.gml3.bindings.GML;
+import org.geotools.xml.AbstractComplexEMFBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
+import org.picocontainer.MutablePicoContainer;
+
 import java.net.URI;
 import javax.xml.namespace.QName;
 
@@ -112,7 +119,7 @@
  *
  * @generated
  */
-public class InsertElementTypeBinding extends AbstractComplexBinding {
+public class InsertElementTypeBinding extends AbstractComplexEMFBinding {
     WfsFactory wfsfactory;
 
     public InsertElementTypeBinding(WfsFactory wfsfactory) {
@@ -136,6 +143,21 @@
         return InsertElementType.class;
     }
 
+    public void initializeChildContext(ElementInstance childInstance, Node node, MutablePicoContainer context) {
+        //if an srsName is set for this geometry, put it in the context for 
+        // children, so they can use it as well
+        if ( node.hasAttribute("srsName") ) {
+            try {
+                CoordinateReferenceSystem crs = GML2ParsingUtils.crs(node);
+                if ( crs != null ) {
+                    context.registerComponentInstance(CoordinateReferenceSystem.class, crs);
+                }
+            } catch(Exception e) {
+                throw new WFSException(e, "InvalidParameterValue");
+            }
+        }
+    }
+    
     /**
      * <!-- begin-user-doc -->
      * <!-- end-user-doc -->
@@ -183,4 +205,15 @@
 
         return insertElement;
     }
+
+    public Object getProperty(Object object, QName name)
+        throws Exception {
+        InsertElementType insert = (InsertElementType) object;
+
+        if (GML._Feature.equals(name)) {
+            return insert.getFeature();
+        }
+
+        return super.getProperty(object, name);
+    }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/XmlSchemaEncoder.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/XmlSchemaEncoder.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/XmlSchemaEncoder.java	(working copy)
@@ -4,19 +4,17 @@
  */
 package org.geoserver.wfs.xml.v1_1_0;
 
-import org.eclipse.xsd.XSDElementDeclaration;
+import net.opengis.wfs.DescribeFeatureTypeType;
+
 import org.eclipse.xsd.XSDSchema;
 import org.eclipse.xsd.util.XSDResourceImpl;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.platform.GeoServerResourceLoader;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
 import org.geoserver.wfs.WFS;
 import org.geoserver.wfs.WFSDescribeFeatureTypeOutputFormat;
 import org.geoserver.wfs.xml.FeatureTypeSchemaBuilder;
-import org.geotools.data.DataStore;
-import org.geotools.data.feature.FeatureAccess;
-import org.opengis.feature.type.AttributeDescriptor;
-import org.opengis.feature.type.Name;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import java.io.IOException;
@@ -47,38 +45,13 @@
 
     protected void write(FeatureTypeInfo[] featureTypeInfos, OutputStream output,
         Operation describeFeatureType) throws IOException {
-        XSDSchema schema = null;
+        //create the schema
+        DescribeFeatureTypeType req = (DescribeFeatureTypeType)describeFeatureType.getParameters()[0];
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(req.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
+        FeatureTypeSchemaBuilder builder = new FeatureTypeSchemaBuilder.GML3(wfs, catalog,
+                resourceLoader);
+        XSDSchema schema = builder.build(featureTypeInfos, proxifiedBaseUrl);
 
-        FeatureTypeInfo fti;
-
-        for (int i = 0; i < featureTypeInfos.length; i++) {
-            fti = featureTypeInfos[i];
-
-            DataStore dataStore = fti.getDataStoreInfo().getDataStore();
-
-            if (dataStore instanceof FeatureAccess) {
-                FeatureAccess fa = (FeatureAccess) dataStore;
-                String uri = fti.getNameSpace().getURI();
-                String localName = fti.getTypeName();
-                Name typeName = new org.geotools.feature.Name(uri, localName);
-                AttributeDescriptor descriptor = (AttributeDescriptor) fa.describe(typeName);
-                XSDElementDeclaration elemDecl = (XSDElementDeclaration) descriptor.getUserData(XSDElementDeclaration.class);
-
-                if (null != elemDecl) {
-                    schema = elemDecl.getSchema();
-
-                    break; //handle only one by now
-                }
-            }
-        }
-
-        if (schema == null) {
-            //create the schema
-            FeatureTypeSchemaBuilder builder = new FeatureTypeSchemaBuilder.GML3(wfs, catalog,
-                    resourceLoader);
-            schema = builder.build(featureTypeInfos);
-        }
-
         //serialize
         schema.updateElement();
         XSDResourceImpl.serialize(output, schema.getElement());
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/TransactionTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/TransactionTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/TransactionTypeBinding.java	(working copy)
@@ -5,9 +5,13 @@
 package org.geoserver.wfs.xml.v1_1_0;
 
 import net.opengis.wfs.AllSomeType;
+import net.opengis.wfs.DeleteElementType;
+import net.opengis.wfs.InsertElementType;
+import net.opengis.wfs.NativeType;
 import net.opengis.wfs.TransactionType;
+import net.opengis.wfs.UpdateElementType;
 import net.opengis.wfs.WfsFactory;
-import org.geotools.xml.AbstractComplexBinding;
+import org.geotools.xml.AbstractComplexEMFBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
 import java.util.Iterator;
@@ -98,7 +102,7 @@
  *
  * @generated
  */
-public class TransactionTypeBinding extends AbstractComplexBinding {
+public class TransactionTypeBinding extends AbstractComplexEMFBinding {
     WfsFactory wfsfactory;
 
     public TransactionTypeBinding(WfsFactory wfsfactory) {
@@ -152,16 +156,16 @@
         //&lt;/xsd:choice&gt;
         for (Iterator itr = node.getChildren().iterator(); itr.hasNext();) {
             Node child = (Node) itr.next();
-            String name = child.getComponent().getName();
+            Object cv = child.getValue();
 
-            if ("Insert".equals(name)) {
-                transaction.getInsert().add(child.getValue());
-            } else if ("Update".equals(name)) {
-                transaction.getUpdate().add(child.getValue());
-            } else if ("Delete".equals(name)) {
-                transaction.getDelete().add(child.getValue());
-            } else if ("Native".equals(name)) {
-                transaction.getNative().add(child.getValue());
+            if (cv instanceof InsertElementType) {
+                transaction.getInsert().add(cv);
+            } else if (cv instanceof UpdateElementType) {
+                transaction.getUpdate().add(cv);
+            } else if (cv instanceof DeleteElementType) {
+                transaction.getDelete().add(cv);
+            } else if (cv instanceof NativeType) {
+                transaction.getNative().add(cv);
             }
         }
 
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSConfiguration.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSConfiguration.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/WFSConfiguration.java	(working copy)
@@ -7,24 +7,17 @@
 import net.opengis.wfs.WfsFactory;
 import org.eclipse.xsd.util.XSDSchemaLocationResolver;
 import org.eclipse.xsd.util.XSDSchemaLocator;
-import org.geoserver.ows.xml.v1_0.OWS;
 import org.geoserver.ows.xml.v1_0.OWSConfiguration;
 import org.geoserver.wfs.xml.FeatureTypeSchemaBuilder;
+import org.geoserver.wfs.xml.PropertyTypePropertyExtractor;
 import org.geoserver.wfs.xml.WFSHandlerFactory;
+import org.geoserver.wfs.xml.XSQNameBinding;
 import org.geoserver.wfs.xml.filter.v1_1.FilterTypeBinding;
 import org.geoserver.wfs.xml.filter.v1_1.PropertyNameTypeBinding;
 import org.geoserver.wfs.xml.gml3.AbstractGeometryTypeBinding;
 import org.geoserver.wfs.xml.gml3.CircleTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOAbstractFeatureTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOCodeTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOCurvePropertyTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOFeaturePropertyExtractor;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOFeaturePropertyTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOMultiPointTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOMultiSurfaceTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOPointTypeBinding;
-import org.geoserver.wfs.xml.v1_1_0.overrides.ISOXSAnyTypeBinding;
 import org.geoserver.wfs.xml.xs.DateBinding;
+import org.geotools.feature.FeatureType;
 import org.geotools.filter.v1_1.OGC;
 import org.geotools.filter.v1_1.OGCConfiguration;
 import org.geotools.gml2.FeatureTypeCache;
@@ -32,13 +25,24 @@
 import org.geotools.gml3.bindings.GML;
 import org.geotools.xml.BindingConfiguration;
 import org.geotools.xml.Configuration;
-import org.geotools.xml.Schemas;
+import org.geotools.xml.OptionalComponentParameter;
 import org.geotools.xs.bindings.XS;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.picocontainer.MutablePicoContainer;
+import org.picocontainer.Parameter;
+import org.picocontainer.defaults.BasicComponentParameter;
+import org.picocontainer.defaults.CachingComponentAdapter;
+import org.picocontainer.defaults.ComponentParameter;
+import org.picocontainer.defaults.SetterInjectionComponentAdapter;
 import org.vfny.geoserver.global.Data;
-import javax.xml.namespace.QName;
+import org.vfny.geoserver.global.FeatureTypeInfo;
+import org.vfny.geoserver.global.GeoServer;
 
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
 
+
 public class WFSConfiguration extends Configuration {
     /**
      * catalog
@@ -55,14 +59,23 @@
 
         this.catalog = catalog;
         this.schemaBuilder = schemaBuilder;
+        
+        catalog.getGeoServer().addListener(
+          new GeoServer.Listener() {
 
+            public void changed() {
+                flush();
+            }
+          }
+        );
+        
         addDependency(new OGCConfiguration());
         addDependency(new GMLConfiguration());
         addDependency(new OWSConfiguration());
     }
 
     public void addDependency(Configuration dependency) {
-        // override to make public
+        //override to make public
         super.addDependency(dependency);
     }
 
@@ -92,89 +105,47 @@
         context.registerComponentInstance(WfsFactory.eINSTANCE);
         context.registerComponentInstance(new WFSHandlerFactory(catalog, schemaBuilder));
         context.registerComponentInstance(catalog);
+        context.registerComponentImplementation(PropertyTypePropertyExtractor.class);
 
-        context.registerComponentImplementation(ISOFeaturePropertyExtractor.class);
-
-        // seed the cache with entries from the catalog
+        //seed the cache with entries from the catalog
         FeatureTypeCache featureTypeCache = (FeatureTypeCache) context
             .getComponentInstanceOfType(FeatureTypeCache.class);
 
-        /*
-         * GR:commented out this block of code as setting up the featuretype
-         * cache is only useful for gml parsing
         try {
             Collection featureTypes = catalog.getFeatureTypeInfos().values();
 
             for (Iterator f = featureTypes.iterator(); f.hasNext();) {
                 FeatureTypeInfo meta = (FeatureTypeInfo) f.next();
+                FeatureType featureType = meta.getFeatureType();
 
-                try {
-                    FeatureType featureType = meta.getFeatureType();
-                    featureTypeCache.put(featureType);
-                } catch (RuntimeException e) {
-                    e.printStackTrace();
-                }
+                featureTypeCache.put(featureType);
             }
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
-        */
     }
 
     protected void configureBindings(MutablePicoContainer container) {
-        // register our custom bindings
+        //register our custom bindings
         container.registerComponentImplementation(XS.DATE, DateBinding.class);
         container.registerComponentImplementation(OGC.Filter, FilterTypeBinding.class);
         container.registerComponentImplementation(OGC.PropertyNameType,
             PropertyNameTypeBinding.class);
         container.registerComponentImplementation(GML.CircleType, CircleTypeBinding.class);
-        container.registerComponentImplementation(GML.AbstractGeometryType,
-            AbstractGeometryTypeBinding.class);
-
-        // remove bindings for MultiPolygon and MultiLineString
-        // TODO: make this cite configurable
-        Schemas.unregisterComponent(container, GML.MultiPolygonType);
-
-        Schemas.unregisterComponent(container, XS.STRING);
-
-        // register the overriding bindings needed to
-        // encode from ISO Features
-        registerBindingOverrides(container);
+        
+        //use setter injection for AbstractGeometryType bindign to allow an 
+        // optional crs to be set in teh binding context for parsing, this crs
+        // is set by the binding of a parent element.
+        // note: it is important that this component adapter is non-caching so 
+        // that the setter property gets updated properly every time
+        container.registerComponent(
+            new SetterInjectionComponentAdapter( 
+                GML.AbstractGeometryType, AbstractGeometryTypeBinding.class, 
+                new Parameter[]{ new OptionalComponentParameter(CoordinateReferenceSystem.class)} 
+            )
+        );
+        
+        // override XSQName binding
+        container.registerComponentImplementation(XS.QNAME, XSQNameBinding.class);
     }
-
-    private void registerBindingOverrides(MutablePicoContainer container) {
-        registerOverride(container, XS.ANYTYPE, ISOXSAnyTypeBinding.class);
-        registerOverride(container, GML.CodeType, ISOCodeTypeBinding.class);
-
-        /*
-        registerOverride(container, XS.DATE, ISOXSDateBinding.class);
-        registerOverride(container, XS.DATETIME, ISOXSDateTimeBinding.class);
-
-        registerOverride(container, XS.COMPLEXTYPE, ISOXSComplexTypeBinding.class);
-        */
-        registerOverride(container, GML.FeaturePropertyType, ISOFeaturePropertyTypeBinding.class);
-        registerOverride(container, GML.AbstractFeatureType, ISOAbstractFeatureTypeBinding.class);
-
-        registerOverride(container, GML.AbstractGeometryType, ISOAbstractFeatureTypeBinding.class);
-
-        registerOverride(container, GML.PointType, ISOPointTypeBinding.class);
-        registerOverride(container, GML.MultiPointType, ISOMultiPointTypeBinding.class);
-        //registerOverride(container, GML.PointPropertyType, ISOPointPropertyTypeBinding.class);
-        registerOverride(container, GML.MultiSurfaceType, ISOMultiSurfaceTypeBinding.class);
-
-        registerOverride(container, GML.CurvePropertyType, ISOCurvePropertyTypeBinding.class);
-    }
-
-    /**
-     * Deregisters the existing binding for the provided <code>name</code>
-     * from the <code>container</code> and registers a new binding for it.
-     *
-     * @param container
-     * @param name
-     * @param newBinding
-     */
-    private void registerOverride(MutablePicoContainer container, QName name, Class newBinding) {
-        Schemas.unregisterComponent(container, name);
-        container.registerComponentImplementation(name, newBinding);
-    }
 }
Index: src/main/java/org/geoserver/wfs/xml/v1_1_0/UpdateElementTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/v1_1_0/UpdateElementTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/v1_1_0/UpdateElementTypeBinding.java	(working copy)
@@ -7,7 +7,7 @@
 import net.opengis.wfs.PropertyType;
 import net.opengis.wfs.UpdateElementType;
 import net.opengis.wfs.WfsFactory;
-import org.geotools.xml.AbstractComplexBinding;
+import org.geotools.xml.AbstractComplexEMFBinding;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
 import org.opengis.filter.Filter;
@@ -109,7 +109,7 @@
  *
  * @generated
  */
-public class UpdateElementTypeBinding extends AbstractComplexBinding {
+public class UpdateElementTypeBinding extends AbstractComplexEMFBinding {
     WfsFactory wfsfactory;
 
     public UpdateElementTypeBinding(WfsFactory wfsfactory) {
@@ -170,4 +170,13 @@
 
         return updateElement;
     }
+
+    public Object getProperty(Object arg0, QName arg1)
+        throws Exception {
+        Object result = super.getProperty(arg0, arg1);
+
+        //System.out.println("Being asked for " + arg1);
+        //System.out.println("Returning " + result);
+        return result;
+    }
 }
Index: src/main/java/org/geoserver/wfs/xml/filter/v1_1/PropertyNameTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/filter/v1_1/PropertyNameTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/filter/v1_1/PropertyNameTypeBinding.java	(working copy)
@@ -43,7 +43,7 @@
         //JD: temporary hack, this should be carried out at evaluation time
         String name = propertyName.getPropertyName();
 
-        if (name.matches("\\w+:\\w+")) {
+        if (name != null && name.matches("\\w+:\\w+")) {
             //namespace qualified name, ensure the prefix is valid
             String prefix = name.substring(0, name.indexOf(':'));
             String namespaceURI = namespaceSupport.getURI(prefix);
Index: src/main/java/org/geoserver/wfs/xml/NameSpaceTranslator.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/NameSpaceTranslator.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/NameSpaceTranslator.java	(working copy)
@@ -292,8 +292,8 @@
      */
     public NameSpaceElement getDefaultElement(Class type) {
         Set posibilities = getElements(type);
-        System.out.println("getting default for type: " + type + " = " + posibilities);
 
+        //System.out.println("getting default for type: " + type + " = " + posibilities);
         if (posibilities.size() == 0) {
             return null;
         }
Index: src/main/java/org/geoserver/wfs/xml/XSProfile.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/XSProfile.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/XSProfile.java	(working copy)
@@ -4,9 +4,16 @@
  */
 package org.geoserver.wfs.xml;
 
+import org.geotools.feature.AttributeTypeFactory;
 import org.geotools.feature.Name;
+import org.geotools.feature.type.ProfileImpl;
+import org.geotools.feature.type.SchemaImpl;
 import org.geotools.xs.XSSchema;
 import org.geotools.xs.bindings.XS;
+import org.opengis.feature.type.Schema;
+
+import java.util.Collections;
+import java.util.Date;
 import java.util.HashSet;
 import java.util.Set;
 import javax.xml.namespace.QName;
@@ -17,26 +24,36 @@
  * mapping unique.
  */
 public class XSProfile extends TypeMappingProfile {
-    static Set profile = new HashSet();
+    static Set profiles = new HashSet();
 
     static {
-        profile.add(name(XS.BYTE)); //Byte.class
-        profile.add(name(XS.HEXBINARY)); //byte[].class 
-        profile.add(name(XS.SHORT)); //Short.class
-        profile.add(name(XS.INT)); //Integer.class
-        profile.add(name(XS.FLOAT)); //Float.class
-        profile.add(name(XS.LONG)); //Long.class
-        profile.add(name(XS.QNAME)); //Qname.class
-        profile.add(name(XS.DATE)); //Date.class
-        profile.add(name(XS.DATETIME)); //Calendar.class
-        profile.add(name(XS.BOOLEAN)); //Boolean.class
-        profile.add(name(XS.DOUBLE)); //Double.class
-        profile.add(name(XS.STRING)); //String.class
-        profile.add(name(XS.INTEGER)); //BigInteger.class
-        profile.add(name(XS.DECIMAL)); //BigDecimal.class
-        profile.add(name(XS.ANYURI)); //URI.class
-
-        profile.add(name(XS.ANYTYPE)); //Map.class
+        Set proper = new HashSet();
+        proper.add(name(XS.BYTE)); //Byte.class
+        proper.add(name(XS.HEXBINARY)); //byte[].class 
+        proper.add(name(XS.SHORT)); //Short.class
+        proper.add(name(XS.INT)); //Integer.class
+        proper.add(name(XS.FLOAT)); //Float.class
+        proper.add(name(XS.LONG)); //Long.class
+        proper.add(name(XS.QNAME)); //Qname.class
+        proper.add(name(XS.DATE)); //java.sql.Date.class
+        proper.add(name(XS.DATETIME)); //java.sql.Timestamp.class
+        proper.add(name(XS.TIME));     //java.sql.Time.class
+        proper.add(name(XS.BOOLEAN)); //Boolean.class
+        proper.add(name(XS.DOUBLE)); //Double.class
+        proper.add(name(XS.STRING)); //String.class
+        proper.add(name(XS.INTEGER)); //BigInteger.class
+        proper.add(name(XS.DECIMAL)); //BigDecimal.class
+        proper.add(name(XS.ANYURI)); //URI.class
+        profiles.add( new ProfileImpl( new XSSchema(), proper ) );
+        
+        //date mappings between java and xml schema are kind of messed up, so 
+        // we create a custom schema which also contains a mapping for 
+        // java.util.Date
+        Schema additional = new SchemaImpl(XS.NAMESPACE);
+        additional.put(name(XS.DATETIME), AttributeTypeFactory.newAttributeType("date", Date.class ));
+        profiles.add( new ProfileImpl( additional, Collections.singleton( name( XS.DATETIME))));
+        
+        //profile.add(name(XS.ANYTYPE)); //Map.class
     }
 
     static Name name(QName qName) {
@@ -44,6 +61,6 @@
     }
 
     public XSProfile() {
-        super(new XSSchema(), profile);
+        super( profiles );
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/FeatureTypeSchema.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/FeatureTypeSchema.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/FeatureTypeSchema.java	(working copy)
@@ -62,12 +62,13 @@
     /**
      * @return The {@link XSDSchema} representation of the schema.
      */
-    public XSDSchema schema() throws IOException {
-        return builder.build(new FeatureTypeInfo[] { featureType });
+    public XSDSchema schema(String baseUrl) throws IOException {
+        return builder.build(new FeatureTypeInfo[] { featureType }, baseUrl);
     }
 
     /**
      * Converts the schema to a gml2 schema.
+     * @param baseUrl is the prefix-base to use for self-referencing urls.
      */
     public FeatureTypeSchema toGML2() {
         if (this instanceof GML2) {
@@ -79,7 +80,6 @@
 
     /**
      * Converts the schema to a gml3 schema.
-     * @return
      */
     public FeatureTypeSchema toGML3() {
         if (this instanceof GML3) {
Index: src/main/java/org/geoserver/wfs/xml/TypeMappingProfile.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/TypeMappingProfile.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/TypeMappingProfile.java	(working copy)
@@ -23,11 +23,21 @@
  * @author Justin Deoliveira, The Open Planning Project
  *
  */
-public class TypeMappingProfile extends ProfileImpl {
-    public TypeMappingProfile(Schema schema, Set profile) {
-        super(schema, profile);
+public class TypeMappingProfile /*extends ProfileImpl*/ {
+    
+    /**
+     * Set of profiles to do mappings from.
+     */
+    Set/*<Profile>*/ profiles;
+    
+//    public TypeMappingProfile(Schema schema, Set profile) {
+//        super(schema, profile);
+//    }
+
+    public TypeMappingProfile(Set profiles) {
+        this.profiles = profiles;
     }
-
+    
     /**
      * Obtains the {@link AttributeType} mapped to a particular class.
      * <p>
@@ -42,16 +52,20 @@
     public AttributeType type(Class clazz) {
         ArrayList assignable = new ArrayList();
 
-        for (Iterator i = values().iterator(); i.hasNext();) {
-            AttributeType type = (AttributeType) i.next();
-
-            if (type.getType().isAssignableFrom(clazz)) {
-                assignable.add(type);
+        for (Iterator p = profiles.iterator(); p.hasNext(); ) {
+            ProfileImpl profile = (ProfileImpl) p.next();
+            
+            for (Iterator i = profile.values().iterator(); i.hasNext();) {
+                AttributeType type = (AttributeType) i.next();
+    
+                if (type.getType().isAssignableFrom(clazz)) {
+                    assignable.add(type);
+                }
+    
+                if (clazz.equals(type.getType())) {
+                    return type;
+                }
             }
-
-            if (clazz.equals(type.getType())) {
-                return type;
-            }
         }
 
         if (assignable.isEmpty()) {
@@ -101,17 +115,21 @@
     public Name name(Class clazz) {
         ArrayList assignable = new ArrayList();
 
-        for (Iterator i = entrySet().iterator(); i.hasNext();) {
-            Map.Entry entry = (Map.Entry) i.next();
-            AttributeType type = (AttributeType) entry.getValue();
-
-            if (type.getType().isAssignableFrom(clazz)) {
-                assignable.add(entry);
+        for (Iterator p = profiles.iterator(); p.hasNext(); ) {
+            ProfileImpl profile = (ProfileImpl) p.next();
+            
+            for (Iterator i = profile.entrySet().iterator(); i.hasNext();) {
+                Map.Entry entry = (Map.Entry) i.next();
+                AttributeType type = (AttributeType) entry.getValue();
+        
+                if (type.getType().isAssignableFrom(clazz)) {
+                    assignable.add(entry);
+                }
+        
+                if (clazz.equals(type.getType())) {
+                    return (Name) entry.getKey();
+                }
             }
-
-            if (clazz.equals(type.getType())) {
-                return (Name) entry.getKey();
-            }
         }
 
         if (assignable.isEmpty()) {
Index: src/main/java/org/geoserver/wfs/xml/GML2Profile.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/GML2Profile.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/GML2Profile.java	(working copy)
@@ -5,6 +5,7 @@
 package org.geoserver.wfs.xml;
 
 import org.geotools.feature.Name;
+import org.geotools.feature.type.ProfileImpl;
 import org.geotools.gml2.GMLSchema;
 import org.geotools.gml2.bindings.GML;
 import java.util.HashSet;
@@ -12,10 +13,11 @@
 
 
 public class GML2Profile extends TypeMappingProfile {
-    static Set profile = new HashSet();
+    static Set profiles = new HashSet();
 
     static {
         //profile.add(new Name(GML.NAMESPACE, GML.POINTTYPE.getLocalPart()));
+        Set profile = new HashSet();
         profile.add(new Name(GML.NAMESPACE, GML.PointPropertyType.getLocalPart()));
         //profile.add(new Name(GML.NAMESPACE, GML.MULTIPOINTTYPE.getLocalPart()));
         profile.add(new Name(GML.NAMESPACE, GML.MultiPointPropertyType.getLocalPart()));
@@ -31,9 +33,10 @@
         profile.add(new Name(GML.NAMESPACE, GML.MultiPolygonPropertyType.getLocalPart()));
 
         profile.add(new Name(GML.NAMESPACE, GML.GeometryPropertyType.getLocalPart()));
+        profiles.add( new ProfileImpl( new GMLSchema(), profile ) );
     }
 
     public GML2Profile() {
-        super(new GMLSchema(), profile);
+        super(profiles);
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/gml3/AbstractGeometryTypeBinding.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/gml3/AbstractGeometryTypeBinding.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/gml3/AbstractGeometryTypeBinding.java	(working copy)
@@ -7,12 +7,17 @@
 import com.vividsolutions.jts.geom.Coordinate;
 import com.vividsolutions.jts.geom.Geometry;
 import org.geoserver.wfs.WFSException;
+import org.geotools.geometry.jts.JTS;
+import org.geotools.gml2.bindings.GML2ParsingUtils;
 import org.geotools.referencing.CRS;
+import org.geotools.referencing.operation.projection.PointOutsideEnvelopeException;
 import org.geotools.xml.ElementInstance;
 import org.geotools.xml.Node;
 import org.opengis.referencing.NoSuchAuthorityCodeException;
 import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.opengis.referencing.cs.CoordinateSystemAxis;
+import org.picocontainer.MutablePicoContainer;
+import org.vfny.geoserver.global.Data;
 
 
 /**
@@ -30,6 +35,29 @@
  *
  */
 public class AbstractGeometryTypeBinding extends org.geotools.gml3.bindings.AbstractGeometryTypeBinding {
+    
+    CoordinateReferenceSystem crs;
+    
+    public void setCRS(CoordinateReferenceSystem crs) {
+        this.crs = crs;
+    }
+
+    public void initializeChildContext(ElementInstance childInstance,
+            Node node, MutablePicoContainer context) {
+        //if an srsName is set for this geometry, put it in the context for 
+        // children, so they can use it as well
+        if ( node.hasAttribute("srsName") ) {
+            try {
+                CoordinateReferenceSystem crs = GML2ParsingUtils.crs(node);
+                if ( crs != null ) {
+                    context.registerComponentInstance(CoordinateReferenceSystem.class, crs);
+                }
+            } catch(Exception e) {
+                throw new WFSException(e, "InvalidParameterValue");
+            }
+        }
+    }
+    
     public Object parse(ElementInstance instance, Node node, Object value)
         throws Exception {
         try {
@@ -46,30 +74,23 @@
         if (geometry != null) {
             //1. ensure a crs is set
             if (geometry.getUserData() == null) {
-                //set to be server "Default"
-                //TODO: actually make this configurable
-                geometry.setUserData(CRS.decode("EPSG:4326"));
+                //no crs set for the geometry, did we inherit one from a parent?
+                if ( crs != null ) {
+                    geometry.setUserData(crs);
+                } else {
+                    // for the moment we don't do anything since we miss the information
+                    // to infer the CRS from the feature type
+                }
             }
 
-            //2. ensure the coordiantes of the geometry fall into valid space defined by crs
+            //2. ensure the coordinates of the geometry fall into valid space defined by crs
             CoordinateReferenceSystem crs = (CoordinateReferenceSystem) geometry.getUserData();
-            Coordinate[] c = geometry.getCoordinates();
-
-            //named x,y, but could be anything
-            CoordinateSystemAxis x = crs.getCoordinateSystem().getAxis(0);
-            CoordinateSystemAxis y = crs.getCoordinateSystem().getAxis(1);
-
-            for (int i = 0; i < c.length; i++) {
-                if ((c[i].x < x.getMinimumValue()) || (c[i].x > x.getMaximumValue())) {
-                    throw new WFSException(c[i].x + " outside of (" + x.getMinimumValue() + ","
-                        + x.getMaximumValue() + ")", "InvalidParameterValue");
+            if(crs != null)
+                try {
+                    JTS.checkCoordinatesRange(geometry, crs);
+                } catch(PointOutsideEnvelopeException e) {
+                    throw new WFSException(e, "InvalidParameterValue");
                 }
-
-                if ((c[i].y < y.getMinimumValue()) || (c[i].y > y.getMaximumValue())) {
-                    throw new WFSException(c[i].y + " outside of (" + y.getMinimumValue() + ","
-                        + y.getMaximumValue() + ")", "InvalidParameterValue");
-                }
-            }
         }
 
         return geometry;
Index: src/main/java/org/geoserver/wfs/xml/GML3Profile.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/GML3Profile.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/GML3Profile.java	(working copy)
@@ -5,16 +5,22 @@
 package org.geoserver.wfs.xml;
 
 import org.geotools.feature.Name;
+import org.geotools.feature.type.ProfileImpl;
 import org.geotools.gml3.GMLSchema;
 import org.geotools.gml3.bindings.GML;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Set;
 
 
 public class GML3Profile extends TypeMappingProfile {
-    static Set profile = new HashSet();
+    static Set profiles = new HashSet();
 
     static {
+        // set with guaranteed iteration order, so that we can put deprecated elements only
+        // after the ones that replaced them
+        Set profile = new LinkedHashSet();
+        
         //basic
         profile.add(new Name(GML.NAMESPACE, GML.MeasureType.getLocalPart()));
 
@@ -34,20 +40,25 @@
         //profile.add( new Name(  GML.NAMESPACE, GML.MultiCurveType.getLocalPart() ) );
         profile.add(new Name(GML.NAMESPACE, GML.MultiCurvePropertyType.getLocalPart()));
 
+        profile.add(new Name(GML.NAMESPACE, GML.SurfacePropertyType.getLocalPart()));
+        //profile.add( new Name(  GML.NAMESPACE, GML.MultiSurfaceType.getLocalPart() ) );
+        profile.add(new Name(GML.NAMESPACE, GML.MultiSurfacePropertyType.getLocalPart()));
+
+        // register polygon and multipolygon only after surface, the iteration order
+        // will make sure surface is found before in any encoding attempt, this way we
+        // are still able to handle polygons, but we don't use them by default
         //profile.add( new Name(  GML.NAMESPACE, GML.PolygonType.getLocalPart() ) );
         profile.add(new Name(GML.NAMESPACE, GML.PolygonPropertyType.getLocalPart()));
-        profile.add(new Name(GML.NAMESPACE, GML.SurfacePropertyType.getLocalPart()));
-
         //profile.add( new Name(  GML.NAMESPACE, GML.MultiPolygonType.getLocalPart() ) );
         profile.add(new Name(GML.NAMESPACE, GML.MultiPolygonPropertyType.getLocalPart()));
-        //profile.add( new Name(  GML.NAMESPACE, GML.MultiSurfaceType.getLocalPart() ) );
-        profile.add(new Name(GML.NAMESPACE, GML.MultiSurfacePropertyType.getLocalPart()));
 
+
         //profile.add( new Name(  GML.NAMESPACE, GML.AbstractGeometryType.getLocalPart() ) );
         profile.add(new Name(GML.NAMESPACE, GML.GeometryPropertyType.getLocalPart()));
+        profiles.add( new ProfileImpl( new GMLSchema(), profile ) );
     }
 
     public GML3Profile() {
-        super(new GMLSchema(), profile);
+        super(profiles);
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/WFSHandlerFactory.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/WFSHandlerFactory.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/WFSHandlerFactory.java	(working copy)
@@ -66,7 +66,7 @@
 
             if (meta != null) {
                 //found it
-                XSDSchema schema = schemaBuilder.build(meta);
+                XSDSchema schema = schemaBuilder.build(meta, null);
 
                 for (Iterator e = schema.getElementDeclarations().iterator(); e.hasNext();) {
                     XSDElementDeclaration element = (XSDElementDeclaration) e.next();
Index: src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java	(working copy)
@@ -9,6 +9,7 @@
 import org.eclipse.xsd.XSDDerivationMethod;
 import org.eclipse.xsd.XSDElementDeclaration;
 import org.eclipse.xsd.XSDFactory;
+import org.eclipse.xsd.XSDForm;
 import org.eclipse.xsd.XSDImport;
 import org.eclipse.xsd.XSDModelGroup;
 import org.eclipse.xsd.XSDParticle;
@@ -16,6 +17,7 @@
 import org.eclipse.xsd.XSDSchemaContent;
 import org.eclipse.xsd.XSDTypeDefinition;
 import org.eclipse.xsd.util.XSDConstants;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.GeoServerResourceLoader;
 import org.geoserver.wfs.WFS;
@@ -82,17 +84,18 @@
         profiles.add(new XSProfile());
     }
 
-    public XSDSchema build(FeatureTypeInfo featureTypeInfo)
+    public XSDSchema build(FeatureTypeInfo featureTypeInfo, String baseUrl)
         throws IOException {
-        return build(new FeatureTypeInfo[] { featureTypeInfo });
+        return build(new FeatureTypeInfo[] { featureTypeInfo }, baseUrl);
     }
 
-    public XSDSchema build(FeatureTypeInfo[] featureTypeInfos)
+    public XSDSchema build(FeatureTypeInfo[] featureTypeInfos, String baseUrl)
         throws IOException {
         XSDFactory factory = XSDFactory.eINSTANCE;
         XSDSchema schema = factory.createXSDSchema();
         schema.setSchemaForSchemaQNamePrefix("xsd");
         schema.getQNamePrefixToNamespaceMap().put("xsd", XSDConstants.SCHEMA_FOR_SCHEMA_URI_2001);
+        schema.setElementFormDefault(XSDForm.get(XSDForm.QUALIFIED));
 
         //group the feature types by namespace
         HashMap ns2featureTypeInfos = new HashMap();
@@ -109,14 +112,18 @@
 
             ns2featureTypeInfos.put(prefix, l);
         }
+        
+        if (baseUrl == null)
+            baseUrl = wfs.getSchemaBaseURL(); 
 
         if (ns2featureTypeInfos.entrySet().size() == 1) {
             //import gml schema
             XSDImport imprt = factory.createXSDImport();
             imprt.setNamespace(gmlNamespace);
-            imprt.setSchemaLocation(ResponseUtils.appendPath(wfs.getSchemaBaseURL(),
-                    gmlSchemaLocation));
 
+            imprt.setSchemaLocation( ResponseUtils.appendPath(baseUrl,
+                    "schemas/" + gmlSchemaLocation));
+
             XSDSchema gmlSchema = gmlSchema();
             imprt.setResolvedSchema(gmlSchema);
 
@@ -154,8 +161,7 @@
                     }
                 }
 
-                String schemaLocation = ResponseUtils.appendQueryString(wfs.getOnlineResource()
-                                                                           .toString(),
+                String schemaLocation = ResponseUtils.appendQueryString(baseUrl,
                         queryString.toString());
                 String namespace = catalog.getNameSpace(prefix).getURI();
 
@@ -229,14 +235,10 @@
         for (int i = 0; i < attributes.length; i++) {
             AttributeType attribute = attributes[i];
 
-            //ignore the attribute types from abstract feature type
-            if ("name".equals(attribute.getName()) || "description".equals(attribute.getName())
-                    || "location".equals(attribute.getName())
-                    || "metaDataProperty".equals(attribute.getName())
-                    || "boundedBy".equals(attribute.getName())) {
+            if ( filterAttributeType( attribute ) ) {
                 continue;
             }
-
+           
             XSDElementDeclaration element = factory.createXSDElementDeclaration();
             element.setName(attribute.getName());
             element.setNillable(attribute.isNillable());
@@ -280,6 +282,8 @@
         schema.updateElement();
     }
 
+   
+    
     Name findTypeName(Class binding) {
         for (Iterator p = profiles.iterator(); p.hasNext();) {
             TypeMappingProfile profile = (TypeMappingProfile) p.next();
@@ -295,6 +299,12 @@
 
     protected abstract XSDSchema gmlSchema();
 
+    protected boolean filterAttributeType( AttributeType attribute ) {
+        return "name".equals( attribute.getName() ) 
+            || "description".equals( attribute.getName()) 
+            || "boundedBy".equals( attribute.getName());
+    }
+    
     public static final class GML2 extends FeatureTypeSchemaBuilder {
         /**
          * Cached gml2 schema
@@ -331,7 +341,7 @@
             profiles.add(new GML3Profile());
 
             gmlNamespace = org.geotools.gml3.bindings.GML.NAMESPACE;
-            gmlSchemaLocation = "gml/3.1.1/base/feature.xsd";
+            gmlSchemaLocation = "gml/3.1.1/base/gml.xsd";
             xmlConfiguration = new org.geotools.gml3.GMLConfiguration();
         }
 
@@ -342,5 +352,11 @@
 
             return gml3Schema;
         }
+        
+        protected boolean filterAttributeType( AttributeType attribute ) {
+            return super.filterAttributeType( attribute ) || 
+                "metaDataProperty".equals( attribute.getName() ) || 
+                "location".equals( attribute.getName() );
+        }
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/GML2OutputFormat.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/GML2OutputFormat.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/GML2OutputFormat.java	(working copy)
@@ -5,6 +5,11 @@
 package org.geoserver.wfs.xml;
 
 import net.opengis.wfs.FeatureCollectionType;
+import net.opengis.wfs.GetFeatureType;
+import net.opengis.wfs.QueryType;
+
+import org.geoserver.ows.util.OwsUtils;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
@@ -14,6 +19,9 @@
 import org.geotools.feature.FeatureType;
 import org.geotools.gml.producer.FeatureTransformer;
 import org.geotools.gml.producer.FeatureTransformer.FeatureTypeNamespaces;
+import org.geotools.gml2.bindings.GML2EncodingUtils;
+import org.geotools.referencing.CRS;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import org.vfny.geoserver.global.GeoServer;
@@ -26,6 +34,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.logging.Level;
 import java.util.zip.GZIPOutputStream;
 import javax.xml.transform.TransformerException;
 
@@ -88,12 +97,16 @@
      * using it.
      */
     public GML2OutputFormat(WFS wfs, GeoServer geoServer, Data catalog) {
-        super("GML2");
+        super(new HashSet(Arrays.asList(new String[] { "GML2", "text/xml; subtype=gml/2.1.2", "GML2-GZIP" })));
 
         this.wfs = wfs;
         this.geoServer = geoServer;
         this.catalog = catalog;
     }
+    
+    public String getCapabilitiesElementName() {
+        return "GML2";
+    }
 
     /**
     * prepares for encoding into GML2 format, optionally compressing its
@@ -104,7 +117,7 @@
     *
     * @throws IOException DOCUMENT ME!
     */
-    public void prepare(String outputFormat, FeatureCollectionType results)
+    public void prepare(String outputFormat, FeatureCollectionType results, GetFeatureType request)
         throws IOException {
         this.compressOutput = formatNameCompressed.equalsIgnoreCase(outputFormat);
 
@@ -116,10 +129,9 @@
         //TODO: the srs is a back, it only will work property when there is 
         // one type, we really need to set it on the feature level
         int srs = -1;
-
-        for (Iterator f = results.getFeature().iterator(); f.hasNext();) {
+        for (int i = 0; i < results.getFeature().size(); i++) {
             //FeatureResults features = (FeatureResults) f.next();
-            FeatureCollection features = (FeatureCollection) f.next();
+            FeatureCollection features = (FeatureCollection) results.getFeature().get(i);
             FeatureType featureType = features.getSchema();
 
             FeatureTypeInfo meta = catalog.getFeatureTypeInfo(featureType.getTypeName(),
@@ -134,11 +146,28 @@
                 String location = (String) ftNamespaces.get(uri);
                 ftNamespaces.put(uri, location + "," + meta.getName());
             } else {
-                String location = typeSchemaLocation(wfs, meta);
+                String location = typeSchemaLocation(wfs, meta, request.getBaseUrl());
                 ftNamespaces.put(uri, location);
             }
 
-            srs = Integer.parseInt(meta.getSRS());
+            //JD: wfs reprojection: should not set srs form metadata but from 
+            // the request
+            //srs = Integer.parseInt(meta.getSRS());
+            QueryType query = (QueryType) request.getQuery().get(i);
+            try {
+                if (query.getSrsName() != null ) {
+                    CoordinateReferenceSystem crs = CRS.decode(query.getSrsName().toString());
+                    String epsgCode = GML2EncodingUtils.epsgCode(crs);
+                    srs = Integer.parseInt(epsgCode);
+                } else {
+                    //no SRS in query...asking for the default?
+                    srs = Integer.parseInt(meta.getSRS());
+                }
+            }
+            catch( Exception e ) {
+                LOGGER.log(Level.WARNING, "Problem encoding:" + query.getSrsName(), e);
+                
+            }
         }
 
         System.setProperty("javax.xml.transform.TransformerFactory",
@@ -149,7 +178,7 @@
         transformer.setFeatureBounding(wfs.isFeatureBounding());
         transformer.setEncoding(wfs.getCharSet());
 
-        String wfsSchemaloc = wfsSchemaLocation(wfs);
+        String wfsSchemaloc = wfsSchemaLocation(wfs,request.getBaseUrl());
         transformer.addSchemaLocation("http://www.opengis.net/wfs", wfsSchemaloc);
 
         for (Iterator it = ftNamespaces.keySet().iterator(); it.hasNext();) {
@@ -168,10 +197,6 @@
         }
     }
 
-    public Set getOutputFormats() {
-        return new HashSet(Arrays.asList(new String[] { "GML2", "text/xml; subtype=gml/2.1.2" }));
-    }
-
     /**
       * DOCUMENT ME!
       *
@@ -190,7 +215,7 @@
      * @throws IOException DOCUMENT ME!
      * @throws IllegalStateException DOCUMENT ME!
      */
-    public void encode(OutputStream output, FeatureCollectionType results)
+    public void encode(OutputStream output, FeatureCollectionType results, GetFeatureType request)
         throws ServiceException, IOException {
         if (results == null) {
             throw new IllegalStateException("It seems prepare() has not been called"
@@ -229,20 +254,24 @@
 
     protected void write(FeatureCollectionType featureCollection, OutputStream output,
         Operation getFeature) throws IOException, ServiceException {
-        prepare("GML2", featureCollection);
-        encode(output, featureCollection);
+        GetFeatureType request = (GetFeatureType)getFeature.getParameters()[0];
+        
+        prepare(request.getOutputFormat(), featureCollection, request);
+        encode(output, featureCollection, request );
     }
 
     protected FeatureTransformer createTransformer() {
         return new FeatureTransformer();
     }
 
-    protected String wfsSchemaLocation(WFS wfs) {
-        return ResponseUtils.appendPath(wfs.getSchemaBaseURL(), "wfs/1.0.0/WFS-basic.xsd");
+    protected String wfsSchemaLocation(WFS wfs, String baseUrl) {
+        return ResponseUtils.appendPath(RequestUtils.proxifiedBaseURL(baseUrl, wfs.getGeoServer().getProxyBaseUrl()),
+                "schemas/wfs/1.0.0/WFS-basic.xsd");
     }
 
-    protected String typeSchemaLocation(WFS wfs, FeatureTypeInfo meta) {
-        return ResponseUtils.appendQueryString(wfs.getOnlineResource().toString(),
-            "version=1.0.0&request=DescribeFeatureType&typeName=" + meta.getName());
+    protected String typeSchemaLocation(WFS wfs, FeatureTypeInfo meta, String baseUrl) {
+        final String proxifiedBase = RequestUtils.proxifiedBaseURL(baseUrl, wfs.getGeoServer().getProxyBaseUrl());
+        return ResponseUtils.appendQueryString(proxifiedBase + "wfs",
+            "service=WFS&version=1.0.0&request=DescribeFeatureType&typeName=" + meta.getName());
     }
 }
Index: src/main/java/org/geoserver/wfs/xml/GML3OutputFormat.java
===================================================================
--- src/main/java/org/geoserver/wfs/xml/GML3OutputFormat.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/xml/GML3OutputFormat.java	(working copy)
@@ -5,22 +5,25 @@
 package org.geoserver.wfs.xml;
 
 import net.opengis.wfs.FeatureCollectionType;
-import org.eclipse.xsd.XSDSchema;
+import net.opengis.wfs.GetFeatureType;
+
+import net.opengis.wfs.BaseRequestType;
+import org.geoserver.ows.util.RequestUtils;
 import org.geoserver.ows.util.ResponseUtils;
 import org.geoserver.platform.Operation;
 import org.geoserver.platform.ServiceException;
-import org.geoserver.wfs.GetFeature;
 import org.geoserver.wfs.WFS;
 import org.geoserver.wfs.WFSGetFeatureOutputFormat;
 import org.geoserver.wfs.xml.v1_1_0.WFSConfiguration;
+import org.geotools.feature.FeatureCollection;
+import org.geotools.feature.FeatureType;
 import org.geotools.xml.Encoder;
-import org.opengis.feature.type.AttributeDescriptor;
-import org.opengis.feature.type.Name;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import org.xml.sax.SAXException;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -35,7 +38,7 @@
     WFSConfiguration configuration;
 
     public GML3OutputFormat(WFS wfs, Data catalog, WFSConfiguration configuration) {
-        super("text/xml; subtype=gml/3.1.1");
+        super(new HashSet(Arrays.asList(new Object[] {"gml3", "text/xml; subtype=gml/3.1.1"})));
 
         this.wfs = wfs;
         this.catalog = catalog;
@@ -45,26 +48,28 @@
     public String getMimeType(Object value, Operation operation) {
         return "text/xml; subtype=gml/3.1.1";
     }
+    
+    public String getCapabilitiesElementName() {
+        return "GML3";
+    }
 
     protected void write(FeatureCollectionType results, OutputStream output, Operation getFeature)
         throws ServiceException, IOException {
         List featureCollections = results.getFeature();
 
-        // round up the info objects for each feature collection
-        HashMap /* <String,Set> */ ns2metas = new HashMap();
+        //round up the info objects for each feature collection
+        HashMap /*<String,Set>*/ ns2metas = new HashMap();
 
         for (Iterator fc = featureCollections.iterator(); fc.hasNext();) {
-            GetFeature.GTHackFeatureCollection features = (GetFeature.GTHackFeatureCollection) fc
-                .next();
-            AttributeDescriptor descriptor = features.getISOFeatureType();
+            FeatureCollection features = (FeatureCollection) fc.next();
+            FeatureType featureType = features.getSchema();
 
-            // load the metadata for the feature type
-            Name name = descriptor.getName();
-            String namespaceURI = name.getNamespaceURI();
-            String localPart = name.getLocalPart();
-            FeatureTypeInfo meta = catalog.getFeatureTypeInfo(localPart, namespaceURI);
+            //load the metadata for the feature type
+            String namespaceURI = featureType.getNamespace().toString();
+            FeatureTypeInfo meta = catalog.getFeatureTypeInfo(featureType.getTypeName(),
+                    namespaceURI);
 
-            // add it to the map
+            //add it to the map
             Set metas = (Set) ns2metas.get(namespaceURI);
 
             if (metas == null) {
@@ -75,14 +80,16 @@
             metas.add(meta);
         }
 
-        XSDSchema schema = configuration.schema();
-        Encoder encoder = new Encoder(configuration, schema);
+        Encoder encoder = new Encoder(configuration, configuration.schema());
 
-        // declare wfs schema location
+        //declare wfs schema location
+        BaseRequestType gft = (BaseRequestType)getFeature.getParameters()[0];
+        
+        String proxifiedBaseUrl = RequestUtils.proxifiedBaseURL(gft.getBaseUrl(), wfs.getGeoServer().getProxyBaseUrl());
         encoder.setSchemaLocation(org.geoserver.wfs.xml.v1_1_0.WFS.NAMESPACE,
-            ResponseUtils.appendPath(wfs.getSchemaBaseURL(), "wfs/1.1.0/wfs.xsd"));
+            ResponseUtils.appendPath(proxifiedBaseUrl, "schemas/wfs/1.1.0/wfs.xsd"));
 
-        // declare application schema namespaces
+        //declare application schema namespaces
         for (Iterator i = ns2metas.entrySet().iterator(); i.hasNext();) {
             Map.Entry entry = (Map.Entry) i.next();
 
@@ -100,9 +107,9 @@
                 }
             }
 
-            // set the schema location
+            //set the schema location
             encoder.setSchemaLocation(namespaceURI,
-                ResponseUtils.appendQueryString(wfs.getOnlineResource().toString(),
+                ResponseUtils.appendQueryString(proxifiedBaseUrl + "wfs",
                     "service=WFS&version=1.1.0&request=DescribeFeatureType&typeName="
                     + typeNames.toString()));
         }
Index: src/main/java/org/geoserver/wfs/kvp/QNameKvpParser.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/QNameKvpParser.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/QNameKvpParser.java	(working copy)
@@ -5,7 +5,10 @@
 package org.geoserver.wfs.kvp;
 
 import org.geoserver.ows.FlatKvpParser;
+import org.geoserver.wfs.WFSException;
 import org.vfny.geoserver.global.Data;
+import org.vfny.geoserver.global.NameSpaceInfo;
+
 import javax.xml.namespace.QName;
 
 
@@ -44,7 +47,13 @@
             String prefix = token.substring(0, i);
             String local = token.substring(i + 1);
 
-            String uri = catalog.getNameSpace(prefix).getURI();
+            String uri = null;
+            if(prefix != null && !"".equals(prefix)) {
+                final NameSpaceInfo namespace = catalog.getNameSpace(prefix);
+                if(namespace == null)
+                    throw new WFSException("Unknown namespace [" + prefix + "]");
+                uri = namespace.getURI();
+            }
 
             return new QName(uri, local, prefix);
         } else {
Index: src/main/java/org/geoserver/wfs/kvp/GetCapabilitiesKvpRequestReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/GetCapabilitiesKvpRequestReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/GetCapabilitiesKvpRequestReader.java	(working copy)
@@ -15,8 +15,8 @@
         super(GetCapabilitiesType.class);
     }
 
-    public Object read(Object request, Map kvp) throws Exception {
-        request = super.read(request, kvp);
+    public Object read(Object request, Map kvp, Map rawKvp) throws Exception {
+        request = super.read(request, kvp, rawKvp);
 
         //set the version attribute on the request
         if (kvp.containsKey("version")) {
Index: src/main/java/org/geoserver/wfs/kvp/ReleaseLockKvpRequestReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/ReleaseLockKvpRequestReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/ReleaseLockKvpRequestReader.java	(working copy)
@@ -17,7 +17,7 @@
         return new String();
     }
 
-    public Object read(Object request, Map kvp) throws Exception {
+    public Object read(Object request, Map kvp, Map rawKvp) throws Exception {
         return kvp.get("lockId");
     }
 }
Index: src/main/java/org/geoserver/wfs/kvp/BBoxKvpParser.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/BBoxKvpParser.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/BBoxKvpParser.java	(working copy)
@@ -10,6 +10,8 @@
 import org.geotools.geometry.jts.ReferencedEnvelope;
 import org.geotools.referencing.CRS;
 import org.opengis.referencing.crs.CoordinateReferenceSystem;
+import org.vfny.geoserver.ServiceException;
+
 import java.util.List;
 
 
@@ -38,7 +40,23 @@
                     + " is not parsable:" + unparsed.get(i));
             }
         }
+        
+        //ensure the values are sane
+        double minx = bbox[0];
+        double miny = bbox[1];
+        double maxx = bbox[2];
+        double maxy = bbox[3];
+        
+        if (minx > maxx) {
+            throw new ServiceException("illegal bbox, minX: " + minx + " is "
+                + "greater than maxX: " + maxx);
+        }
 
+        if (miny > maxy) {
+            throw new ServiceException("illegal bbox, minY: " + miny + " is "
+                + "greater than maxY: " + maxy);
+        }
+
         //check for crs
         CoordinateReferenceSystem crs = null;
 
@@ -48,6 +66,6 @@
             //TODO: use the default crs of the system
         }
 
-        return new ReferencedEnvelope(bbox[0], bbox[2], bbox[1], bbox[3], crs);
+        return new ReferencedEnvelope(minx,maxx,miny,maxy,crs);
     }
 }
Index: src/main/java/org/geoserver/wfs/kvp/GetFeatureKvpRequestReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/GetFeatureKvpRequestReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/GetFeatureKvpRequestReader.java	(working copy)
@@ -9,18 +9,24 @@
 import org.eclipse.emf.ecore.EObject;
 import org.geoserver.wfs.WFSException;
 import org.geotools.feature.FeatureType;
+import org.geotools.geometry.jts.ReferencedEnvelope;
+import org.geotools.gml2.bindings.GML2EncodingUtils;
 import org.geotools.xml.EMFUtils;
 import org.opengis.filter.Filter;
 import org.opengis.filter.FilterFactory;
 import org.opengis.filter.identity.FeatureId;
 import org.opengis.filter.spatial.BBOX;
+import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+
 import javax.xml.namespace.QName;
 
 
@@ -44,27 +50,12 @@
     /**
      * Performs additinon GetFeature kvp parsing requirements
      */
-    public Object read(Object request, Map kvp) throws Exception {
-        request = super.read(request, kvp);
+    public Object read(Object request, Map kvp, Map rawKvp) throws Exception {
+        request = super.read(request, kvp, rawKvp);
 
-        //make sure not both featureid and filter specified
-        if (kvp.containsKey("featureId") && kvp.containsKey("filter")) {
-            String msg = "featureid and filter both specified but are mutually exclusive";
-            throw new WFSException(msg);
-        }
+        // make sure the filter is specified in just one way
+        ensureMutuallyExclusive(kvp, new String[] { "featureId", "filter", "bbox", "cql_filter" });
 
-        //make sure not both featureid and bbox specified
-        if (kvp.containsKey("featureId") && kvp.containsKey("bbox")) {
-            String msg = "featureid and bbox both specified but are mutually exclusive";
-            throw new WFSException(msg);
-        }
-
-        //make sure not both filter and bbox specified
-        if (kvp.containsKey("filter") && kvp.containsKey("bbox")) {
-            String msg = "bbox and filter both specified but are mutually exclusive";
-            throw new WFSException(msg);
-        }
-
         //get feature has some additional parsing requirements
         EObject eObject = (EObject) request;
 
@@ -126,19 +117,20 @@
         //filter
         if (kvp.containsKey("filter")) {
             querySet(eObject, "filter", (List) kvp.get("filter"));
+        } else if (kvp.containsKey("cql_filter")) {
+            querySet(eObject, "filter", (List) kvp.get("cql_filter"));
         } else if (kvp.containsKey("featureId")) {
             //set filter from featureId
             List featureIdList = (List) kvp.get("featureId");
-            List filters = new ArrayList();
+            Set ids = new HashSet();
 
             for (Iterator i = featureIdList.iterator(); i.hasNext();) {
                 String fid = (String) i.next();
                 FeatureId featureId = filterFactory.featureId(fid);
-
-                HashSet featureIds = new HashSet();
-                featureIds.add(featureId);
-                filters.add(filterFactory.id(featureIds));
+               ids.add(featureId);
             }
+            // build a single feature id filter
+            List filters = Collections.singletonList(filterFactory.id(ids));
 
             querySet(eObject, "filter", filters);
         } else if (kvp.containsKey("bbox")) {
@@ -182,18 +174,60 @@
             querySet(eObject, "sortBy", (List) kvp.get("sortBy"));
         }
 
+        //srsName
+        if (kvp.containsKey("srsName")) {
+            querySet(eObject, "srsName",(List)kvp.get("srsName"));
+        }
+
+        //featureversion
+        if (kvp.containsKey("featureVersion")) {
+            querySet(eObject, "featureVersion",
+                Collections.singletonList((String) kvp.get("featureVersion")));
+        }
+
         return request;
     }
 
+    /**
+     * Given a set of keys, this method will ensure that no two keys are specified at the same time
+     * @param kvp
+     * @param keys
+     */
+    private void ensureMutuallyExclusive(Map kvp, String[] keys) {
+        for (int i = 0; i < keys.length; i++) {
+            if (kvp.containsKey(keys[i])) {
+                for (int j = i + 1; j < keys.length; j++) {
+                    if (kvp.containsKey(keys[j])) {
+                        String msg = keys[i] + " and " + keys[j]
+                            + " both specified but are mutually exclusive";
+                        throw new WFSException(msg);
+                    }
+                }
+            }
+        }
+    }
+
     BBOX bboxFilter(QName typeName, Envelope bbox) throws Exception {
         FeatureTypeInfo featureTypeInfo = catalog.getFeatureTypeInfo(typeName);
         FeatureType featureType = featureTypeInfo.getFeatureType();
 
         //TODO: should this be applied to all geometries?
         String name = featureType.getDefaultGeometry().getName();
-
+        
+        //get the epsg code
+        String epsgCode = null;
+        if ( bbox instanceof ReferencedEnvelope ) {
+            CoordinateReferenceSystem crs = ((ReferencedEnvelope)bbox).getCoordinateReferenceSystem();
+            if ( crs != null ) {
+                epsgCode = GML2EncodingUtils.epsgCode(crs);
+                if ( epsgCode != null ) {
+                    epsgCode = "EPSG:" + epsgCode;
+                }
+            }
+        }
+        
         return filterFactory.bbox(name, bbox.getMinX(), bbox.getMinY(), bbox.getMaxX(),
-            bbox.getMaxY(), null);
+            bbox.getMaxY(), epsgCode);
     }
 
     protected void querySet(EObject request, String property, List values)
Index: src/main/java/org/geoserver/wfs/kvp/FilterKvpReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/FilterKvpReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/FilterKvpReader.java	(working copy)
@@ -1,56 +0,0 @@
-/* Copyright (c) 2001 - 2007 TOPP - www.openplans.org. All rights reserved.
- * This code is licensed under the GPL 2.0 license, availible at the root
- * application directory.
- */
-package org.geoserver.wfs.kvp;
-
-import org.geoserver.ows.KvpParser;
-import org.geoserver.ows.util.KvpUtils;
-import org.geotools.filter.v1_0.OGCConfiguration;
-import org.geotools.xml.Configuration;
-import org.geotools.xml.Parser;
-import org.opengis.filter.Filter;
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-
-public class FilterKvpReader extends KvpParser {
-    public FilterKvpReader() {
-        super("filter", List.class);
-    }
-
-    public Object parse(String value) throws Exception {
-        //create the parser
-        Configuration configuration = new OGCConfiguration();
-        Parser parser = new Parser(configuration);
-
-        //seperate the individual filter strings
-        List unparsed = KvpUtils.readFlat(value, KvpUtils.OUTER_DELIMETER);
-        List filters = new ArrayList();
-
-        Iterator i = unparsed.listIterator();
-
-        while (i.hasNext()) {
-            String string = (String) i.next();
-            InputStream input = new ByteArrayInputStream(string.getBytes());
-
-            try {
-                Filter filter = (Filter) parser.parse(input);
-
-                if (filter == null) {
-                    throw new NullPointerException();
-                }
-
-                filters.add(filter);
-            } catch (Exception e) {
-                String msg = "Unable to parse filter: " + string;
-                throw new RuntimeException(msg, e);
-            }
-        }
-
-        return filters;
-    }
-}
Index: src/main/java/org/geoserver/wfs/kvp/DescribeFeatureTypeKvpRequestReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/DescribeFeatureTypeKvpRequestReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/DescribeFeatureTypeKvpRequestReader.java	(working copy)
@@ -13,9 +13,9 @@
         super(DescribeFeatureTypeType.class);
     }
 
-    public Object read(Object request, Map kvp) throws Exception {
+    public Object read(Object request, Map kvp, Map rawKvp) throws Exception {
         //let super do its thing
-        request = super.read(request, kvp);
+        request = super.read(request, kvp, rawKvp);
 
         //do an additional check for outputFormat, because the default 
         // in wfs 1.1 is not the default for wfs 1.0
Index: src/main/java/org/geoserver/wfs/kvp/WFSKvpRequestReader.java
===================================================================
--- src/main/java/org/geoserver/wfs/kvp/WFSKvpRequestReader.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/kvp/WFSKvpRequestReader.java	(working copy)
@@ -68,7 +68,7 @@
         }
     }
 
-    public Object read(Object request, Map kvp) throws Exception {
+    public Object read(Object request, Map kvp, Map rawKvp) throws Exception {
         //use emf reflection
         EObject eObject = (EObject) request;
 
Index: src/main/java/org/geoserver/wfs/Transaction.java
===================================================================
--- src/main/java/org/geoserver/wfs/Transaction.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/Transaction.java	(working copy)
@@ -4,54 +4,38 @@
  */
 package org.geoserver.wfs;
 
-import com.vividsolutions.jts.geom.Envelope;
 import net.opengis.wfs.ActionType;
 import net.opengis.wfs.AllSomeType;
-import net.opengis.wfs.DeleteElementType;
-import net.opengis.wfs.InsertElementType;
 import net.opengis.wfs.InsertedFeatureType;
-import net.opengis.wfs.NativeType;
-import net.opengis.wfs.PropertyType;
 import net.opengis.wfs.TransactionResponseType;
 import net.opengis.wfs.TransactionType;
-import net.opengis.wfs.UpdateElementType;
 import net.opengis.wfs.WfsFactory;
+
+import org.acegisecurity.Authentication;
+import org.acegisecurity.context.SecurityContextHolder;
+import org.acegisecurity.userdetails.UserDetails;
 import org.eclipse.emf.ecore.EObject;
 import org.eclipse.emf.ecore.util.FeatureMap;
-import org.geoserver.feature.ReprojectingFeatureCollection;
+import org.geoserver.platform.GeoServerExtensions;
 import org.geoserver.platform.ServiceException;
-import org.geotools.data.DataStore;
-import org.geotools.data.DefaultQuery;
 import org.geotools.data.DefaultTransaction;
-import org.geotools.data.FeatureLocking;
 import org.geotools.data.FeatureSource;
 import org.geotools.data.FeatureStore;
-import org.geotools.data.FeatureWriter;
-import org.geotools.factory.CommonFactoryFinder;
-import org.geotools.feature.AttributeType;
-import org.geotools.feature.DefaultFeatureCollection;
-import org.geotools.feature.Feature;
-import org.geotools.feature.FeatureCollection;
-import org.geotools.feature.FeatureType;
-import org.geotools.referencing.CRS;
 import org.geotools.xml.EMFUtils;
-import org.opengis.filter.Filter;
 import org.opengis.filter.FilterFactory;
-import org.opengis.filter.Id;
-import org.opengis.referencing.crs.CoordinateReferenceSystem;
+import org.springframework.context.ApplicationContext;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
-import java.util.LinkedList;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.xml.namespace.QName;
@@ -72,24 +56,37 @@
     /**
      * WFS configuration
      */
-    WFS wfs;
+    protected WFS wfs;
 
     /**
      * The catalog
      */
-    Data catalog;
+    protected Data catalog;
 
     /**
      * Filter factory
      */
-    FilterFactory filterFactory;
+    protected FilterFactory filterFactory;
 
     /** Geotools2 transaction used for this opperations */
     protected org.geotools.data.Transaction transaction;
+    protected List transactionElementHandlers = new ArrayList();
+    protected List transactionListeners = new ArrayList();
+    protected List transactionPlugins = new ArrayList();
 
-    public Transaction(WFS wfs, Data catalog) {
+    public Transaction(WFS wfs, Data catalog, ApplicationContext context) {
         this.wfs = wfs;
         this.catalog = catalog;
+        // register element handlers, listeners and plugins
+        transactionElementHandlers.addAll(GeoServerExtensions.extensions(TransactionElementHandler.class));
+        transactionListeners.addAll(GeoServerExtensions.extensions(TransactionListener.class));
+        transactionPlugins.addAll(GeoServerExtensions.extensions(TransactionPlugin.class));
+        // plugins are listeners too, but I want to make sure they are notified
+        // of
+        // changes in the same order as the other plugin callbacks
+        transactionListeners.removeAll(transactionPlugins);
+        // sort plugins according to priority
+        Collections.sort(transactionPlugins, new TransactionPluginComparator());
     }
 
     public void setFilterFactory(FilterFactory filterFactory) {
@@ -98,7 +95,7 @@
 
     public TransactionResponseType transaction(TransactionType request)
         throws WFSException {
-        //make sure server is supporting transactions
+        // make sure server is supporting transactions
         if ((wfs.getServiceLevel() & WFS.TRANSACTIONAL) == 0) {
             throw new WFSException("Transaction support is not enabled");
         }
@@ -106,65 +103,69 @@
         try {
             return execute(request);
         } catch (WFSException e) {
-            abort(request); //release any locks
+            abort(request); // release any locks
             throw e;
         } catch (Exception e) {
-            abort(request); //release any locks
+            abort(request); // release any locks
             throw new WFSException(e);
         }
     }
 
     /**
-    * Execute Transaction request.
-    *
-    * <p>
-    * The results of this opperation are stored for use by writeTo:
-    *
-    * <ul>
-    * <li>
-    * transaction: used by abort & writeTo to commit/rollback
-    * </li>
-    * <li>
-    * request: used for users getHandle information to report errors
-    * </li>
-    * <li>
-    * stores: FeatureStores required for Transaction
-    * </li>
-    * <li>
-    * failures: List of failures produced
-    * </li>
-    * </ul>
-    * </p>
-    *
-    * <p>
-    * Because we are using geotools2 locking facilities our modification will
-    * simply fail with IOException if we have not provided proper
-    * authorization.
-    * </p>
-    *
-    * <p>
-    * The specification allows a WFS to implement PARTIAL sucess if it is
-    * unable to rollback all the requested changes.  This implementation is
-    * able to offer full Rollback support and will not require the use of
-    * PARTIAL success.
-    * </p>
-    *
-    * @param transactionRequest
-    *
-    * @throws ServiceException DOCUMENT ME!
-    * @throws WfsException
-    * @throws WfsTransactionException DOCUMENT ME!
-    */
+     * Execute Transaction request.
+     *
+     * <p>
+     * The results of this opperation are stored for use by writeTo:
+     *
+     * <ul>
+     * <li> transaction: used by abort & writeTo to commit/rollback </li>
+     * <li> request: used for users getHandle information to report errors </li>
+     * <li> stores: FeatureStores required for Transaction </li>
+     * <li> failures: List of failures produced </li>
+     * </ul>
+     * </p>
+     *
+     * <p>
+     * Because we are using geotools2 locking facilities our modification will
+     * simply fail with IOException if we have not provided proper
+     * authorization.
+     * </p>
+     *
+     * <p>
+     * The specification allows a WFS to implement PARTIAL sucess if it is
+     * unable to rollback all the requested changes. This implementation is able
+     * to offer full Rollback support and will not require the use of PARTIAL
+     * success.
+     * </p>
+     *
+     * @param transactionRequest
+     *
+     * @throws ServiceException
+     *             DOCUMENT ME!
+     * @throws WfsException
+     * @throws WfsTransactionException
+     *             DOCUMENT ME!
+     */
     protected TransactionResponseType execute(TransactionType request)
         throws Exception {
-        //some defaults
+        // some defaults
         if (request.getReleaseAction() == null) {
             request.setReleaseAction(AllSomeType.ALL_LITERAL);
         }
 
-        //the geotools transaction
-        transaction = new DefaultTransaction();
+        // inform plugins we're about to start, and let them eventually
+        // alter the request
+        for (Iterator it = transactionPlugins.iterator(); it.hasNext();) {
+            TransactionPlugin tp = (TransactionPlugin) it.next();
+            tp.beforeTransaction(request);
+        }
 
+        // setup the transaction listener multiplexer
+        TransactionListenerMux multiplexer = new TransactionListenerMux();
+
+        // the geotools transaction
+        transaction = getDatastoreTransaction(request);
+
         //
         // We are going to preprocess our elements,
         // gathering all the FeatureSources we need
@@ -176,120 +177,68 @@
         // (This will be added to the contents are harmed)
         Map stores2 = new HashMap();
 
-        // List of type names, maintain this list because of the insert hack described below
-        //List typeNames = new ArrayList();
+        // List of type names, maintain this list because of the insert hack
+        // described below
+        // List typeNames = new ArrayList();
+        Map elementHandlers = gatherElementHandlers(request.getGroup());
 
-        // Gather FeatureStores required by Transaction Elements
+        // Gather feature types required by transaction elements and validate
+        // the elements
+        // finally gather FeatureStores required by Transaction Elements
         // and configure them with our transaction
         //
         // (I am using element rather than transaction sub request
         // to agree with the spec docs)
-        for (Iterator i = request.getGroup().iterator(); i.hasNext();) {
-            FeatureMap.Entry entry = (FeatureMap.Entry) i.next();
-            EObject element = (EObject) entry.getValue();
+        for (Iterator it = elementHandlers.entrySet().iterator(); it.hasNext();) {
+            Map.Entry entry = (Map.Entry) it.next();
+            EObject element = (EObject) entry.getKey();
+            TransactionElementHandler handler = (TransactionElementHandler) entry.getValue();
+            Map featureTypeInfos = new HashMap();
 
-            List metas = new ArrayList();
+            QName[] typeNames = handler.getTypeNames(element);
 
-            if (element instanceof NativeType) {
-                NativeType nativ = (NativeType) element;
+            for (int i = 0; i < typeNames.length; i++) {
+                final QName typeName = typeNames[i];
+                final String name = typeName.getLocalPart();
+                final String namespaceURI;
 
-                if (!nativ.isSafeToIgnore()) {
-                    throw new WFSException("Native element:" + nativ.getVendorId()
-                        + " unsupported but marked as" + " unsafe to ignore",
-                        "InvalidParameterValue");
+                if (typeName.getNamespaceURI() != null) {
+                    namespaceURI = typeName.getNamespaceURI();
+                } else {
+                    namespaceURI = catalog.getDefaultNameSpace().getURI();
                 }
-            }
 
-            if (element instanceof InsertElementType) {
-                InsertElementType insert = (InsertElementType) element;
+                LOGGER.fine("Locating FeatureSource uri:'" + namespaceURI + "' name:'" + name + "'");
 
-                // Option 1: Guess FeatureStore based on insert request
-                //
-                if (!insert.getFeature().isEmpty()) {
-                    for (Iterator f = insert.getFeature().iterator(); f.hasNext();) {
-                        Feature feature = (Feature) f.next();
+                final FeatureTypeInfo meta = catalog.getFeatureTypeInfo(name, namespaceURI);
 
-                        String name = feature.getFeatureType().getTypeName();
-                        String namespaceURI = null;
-
-                        if (feature.getFeatureType().getNamespace() != null) {
-                            namespaceURI = feature.getFeatureType().getNamespace().toString();
-                        } else {
-                            //default
-                            namespaceURI = catalog.getDefaultNameSpace().getURI();
-                        }
-
-                        LOGGER.fine("Locating FeatureSource uri:'" + namespaceURI + "' name:'"
-                            + name + "'");
-
-                        FeatureTypeInfo meta = catalog.getFeatureTypeInfo(name, namespaceURI);
-
-                        if (meta == null) {
-                            String msg = name + " is not available: ";
-                            String handle = (String) EMFUtils.get(element, "handle");
-                            throw new WFSTransactionException(msg, (String) null, handle);
-                        }
-
-                        metas.add(meta);
-                    }
-                } else {
-                    LOGGER.finer("Insert was empty - does not need a FeatuerSoruce");
-
-                    continue; // insert is actually empty
-                }
-            } else {
-                // Option 2: either update or delete, only one type
-                QName elementName = (QName) EMFUtils.get(element, "typeName");
-                FeatureTypeInfo meta = catalog.getFeatureTypeInfo(elementName);
-
                 if (meta == null) {
-                    String msg = elementName + " is not available: ";
+                    String msg = name + " is not available: ";
                     String handle = (String) EMFUtils.get(element, "handle");
                     throw new WFSTransactionException(msg, (String) null, handle);
                 }
 
-                metas.add(meta);
-
-                if (element instanceof DeleteElementType) {
-                    //check that a filter was specified
-                    DeleteElementType delete = (DeleteElementType) element;
-
-                    if (delete.getFilter() == null) {
-                        throw new WFSException("Must specify filter for delete",
-                            "MissingParameterValue");
-                    }
-                }
-
-                if (element instanceof UpdateElementType) {
-                    //check for case of updating an element with null value
-                    UpdateElementType update = (UpdateElementType) element;
-                    FeatureType featureType = meta.getFeatureType();
-
-                    for (Iterator prop = update.getProperty().iterator(); prop.hasNext();) {
-                        PropertyType property = (PropertyType) prop.next();
-
-                        if (property.getValue() == null) {
-                            AttributeType attributeType = featureType.getAttributeType(property.getName()
-                                                                                               .getLocalPart());
-
-                            if ((attributeType != null) && (attributeType.getMinOccurs() > 0)) {
-                                String msg = "Property '" + attributeType.getName()
-                                    + "' is mandatory " + "but no value specified.";
-                                throw new WFSException(msg, "MissingParameterValue");
-                            }
-                        }
-                    }
-                }
+                featureTypeInfos.put(typeName, meta);
             }
 
-            //go through all meta data objects, and load feature stores
-            for (Iterator m = metas.iterator(); m.hasNext();) {
+            // check element validity
+            handler.checkValidity(element, featureTypeInfos);
+
+            // go through all feature type infos data objects, and load feature
+            // stores
+            for (Iterator m = featureTypeInfos.values().iterator(); m.hasNext();) {
                 FeatureTypeInfo meta = (FeatureTypeInfo) m.next();
                 String typeRef = meta.getDataStoreInfo().getId() + ":" + meta.getTypeName();
 
-                QName elementName = new QName(meta.getNameSpace().getURI(), meta.getTypeName(),
+                String URI = meta.getNameSpace().getURI();
+                QName elementName = new QName(URI, meta.getTypeName(),
                         meta.getNameSpace().getPrefix());
+                QName elementNameDefault = null;
 
+                if (catalog.getDefaultNameSpace().getURI().equals(URI)) {
+                    elementNameDefault = new QName(meta.getTypeName());
+                }
+
                 LOGGER.fine("located FeatureType w/ typeRef '" + typeRef + "' and elementName '"
                     + elementName + "'");
 
@@ -305,6 +254,11 @@
                         FeatureStore store = (FeatureStore) source;
                         store.setTransaction(transaction);
                         stores.put(elementName, source);
+
+                        if (elementNameDefault != null) {
+                            stores.put(elementNameDefault, source);
+                        }
+
                         stores2.put(typeRef, source);
                     } else {
                         String msg = elementName + " is read-only";
@@ -348,366 +302,36 @@
             }
         }
 
-        //result
+        // result
         TransactionResponseType result = WfsFactory.eINSTANCE.createTransactionResponseType();
         result.setTransactionResults(WfsFactory.eINSTANCE.createTransactionResultsType());
         result.getTransactionResults().setHandle(request.getHandle());
         result.setTransactionSummary(WfsFactory.eINSTANCE.createTransactionSummaryType());
+        result.getTransactionSummary().setTotalInserted(BigInteger.valueOf(0));
+        result.getTransactionSummary().setTotalUpdated(BigInteger.valueOf(0));
+        result.getTransactionSummary().setTotalDeleted(BigInteger.valueOf(0));
+
         result.setInsertResults(WfsFactory.eINSTANCE.createInsertResultsType());
 
-        //operatinos counters
-        long deleted = 0;
-        long inserted = 0;
-        long updated = 0;
+        // execute elements in order, recording results as we go
+        // I will need to record the damaged area for pre commit validation
+        // checks
+        // Envelope envelope = new Envelope();
+        boolean exception = false;
 
-        // execute elements in order,
-        // recording results as we go
-        //
-        // I will need to record the damaged area for
-        // pre commit validation checks
-        //
-        Envelope envelope = new Envelope();
-
         try {
-            for (int i = 0; i < request.getGroup().size(); i++) {
-                FeatureMap.Entry entry = (FeatureMap.Entry) request.getGroup().get(i);
-                EObject element = (EObject) entry.getValue();
+            for (Iterator it = elementHandlers.entrySet().iterator(); it.hasNext();) {
+                Map.Entry entry = (Map.Entry) it.next();
+                EObject element = (EObject) entry.getKey();
+                TransactionElementHandler handler = (TransactionElementHandler) entry.getValue();
 
-                // We expect element name to be of the format prefix:typeName
-                // We take care to force the insert element to have this format above.
-                //
-                if (element instanceof UpdateElementType || element instanceof DeleteElementType) {
-                    QName elementName = (QName) EMFUtils.get(element, "typeName");
-                    String handle = (String) EMFUtils.get(element, "handle");
-
-                    FeatureStore store = (FeatureStore) stores.get(elementName);
-
-                    if (store == null) {
-                        throw new WFSException("Could not locate FeatureStore for '" + elementName
-                            + "'");
-                    }
-
-                    String typeName = store.getSchema().getTypeName();
-
-                    if (element instanceof DeleteElementType) {
-                        if ((wfs.getServiceLevel() & WFS.SERVICE_DELETE) == 0) {
-                            // could we catch this during the handler, rather than during execution?
-                            throw new WFSException("Transaction Delete support is not enabled");
-                        }
-
-                        DeleteElementType delete = (DeleteElementType) element;
-
-                        //do a check for Filter.NONE, the spec specifically does not
-                        // allow this
-                        if (delete.getFilter() == Filter.INCLUDE) {
-                            throw new WFSException("Filter must be supplied for Transaction Delete");
-                        }
-
-                        LOGGER.finer("Transaction Delete:" + element);
-
-                        try {
-                            Filter filter = (Filter) delete.getFilter();
-
-                            Envelope damaged = store.getBounds(new DefaultQuery(
-                                        delete.getTypeName().getLocalPart(), filter));
-
-                            if (damaged == null) {
-                                damaged = store.getFeatures(filter).getBounds();
-                            }
-
-                            if ((request.getLockId() != null) && store instanceof FeatureLocking
-                                    && (request.getReleaseAction() == AllSomeType.SOME_LITERAL)) {
-                                FeatureLocking locking = (FeatureLocking) store;
-
-                                // TODO: Revisit Lock/Delete interaction in gt2 
-                                if (false) {
-                                    // REVISIT: This is bad - by releasing locks before
-                                    // we remove features we open ourselves up to the danger
-                                    // of someone else locking the features we are about to
-                                    // remove.
-                                    //
-                                    // We cannot do it the other way round, as the Features will
-                                    // not exist
-                                    //
-                                    // We cannot grab the fids offline using AUTO_COMMIT
-                                    // because we may have removed some of them earlier in the
-                                    // transaction
-                                    //
-                                    locking.unLockFeatures(filter);
-                                    store.removeFeatures(filter);
-                                } else {
-                                    // This a bit better and what should be done, we will
-                                    // need to rework the gt2 locking api to work with
-                                    // fids or something
-                                    //
-                                    // The only other thing that would work would be
-                                    // to specify that FeatureLocking is required to
-                                    // remove locks when removing Features.
-                                    // 
-                                    // While that sounds like a good idea, it would be
-                                    // extra work when doing release mode ALL.
-                                    // 
-                                    DataStore data = store.getDataStore();
-                                    FilterFactory factory = CommonFactoryFinder.getFilterFactory(null);
-                                    FeatureWriter writer;
-                                    writer = data.getFeatureWriter(typeName, filter, transaction);
-
-                                    try {
-                                        while (writer.hasNext()) {
-                                            String fid = writer.next().getID();
-                                            Set featureIds = new HashSet();
-                                            featureIds.add(factory.featureId(fid));
-                                            locking.unLockFeatures(factory.id(featureIds));
-                                            writer.remove();
-                                            deleted++;
-                                        }
-                                    } finally {
-                                        writer.close();
-                                    }
-
-                                    store.removeFeatures(filter);
-                                }
-                            } else {
-                                // We don't have to worry about locking right now
-                                //
-                                //store.removeFeatures(filter);
-                                //JD: changing to track number of deletes
-                                FeatureWriter writer = store.getDataStore()
-                                                            .getFeatureWriter(typeName, filter,
-                                        transaction);
-
-                                try {
-                                    while (writer.hasNext()) {
-                                        writer.next();
-                                        writer.remove();
-                                        deleted++;
-                                    }
-                                } finally {
-                                    writer.close();
-                                }
-                            }
-
-                            envelope.expandToInclude(damaged);
-                        } catch (IOException ioException) {
-                            String msg = ioException.getMessage();
-                            String eHandle = (String) EMFUtils.get(element, "handle");
-                            throw new WFSTransactionException(msg, (String) null, eHandle, handle);
-                        }
-                    } //end delete
-
-                    if (element instanceof UpdateElementType) {
-                        if ((wfs.getServiceLevel() & WFS.SERVICE_UPDATE) == 0) {
-                            // could we catch this during the handler, rather than during execution?
-                            throw new WFSException("Transaction Update support is not enabled");
-                        }
-
-                        LOGGER.finer("Transaction Update:" + element);
-
-                        UpdateElementType update = (UpdateElementType) element;
-
-                        try {
-                            Filter filter = (Filter) update.getFilter();
-
-                            AttributeType[] types = new AttributeType[update.getProperty().size()];
-                            Object[] values = new Object[update.getProperty().size()];
-
-                            for (int j = 0; j < update.getProperty().size(); j++) {
-                                PropertyType property = (PropertyType) update.getProperty().get(j);
-                                types[j] = store.getSchema()
-                                                .getAttributeType(property.getName().getLocalPart());
-                                values[j] = property.getValue();
-                            }
-
-                            // Pass through data to collect fids and damaged region
-                            // for validation
-                            //
-                            Set fids = new HashSet();
-                            LOGGER.finer("Preprocess to remember modification as a set of fids");
-
-                            FeatureCollection features = store.getFeatures(filter);
-                            Iterator preprocess = features.iterator();
-
-                            try {
-                                while (preprocess.hasNext()) {
-                                    Feature feature = (Feature) preprocess.next();
-                                    fids.add(feature.getID());
-                                    envelope.expandToInclude(feature.getBounds());
-                                }
-                            } catch (NoSuchElementException e) {
-                                throw new WFSException("Could not aquire FeatureIDs", e);
-                            } finally {
-                                features.close(preprocess);
-                            }
-
-                            try {
-                                if (types.length == 1) {
-                                    store.modifyFeatures(types[0], values[0], filter);
-                                } else {
-                                    store.modifyFeatures(types, values, filter);
-                                }
-                            } finally {
-                                // make sure we unlock
-                                if ((request.getLockId() != null)
-                                        && store instanceof FeatureLocking
-                                        && (request.getReleaseAction() == AllSomeType.SOME_LITERAL)) {
-                                    FeatureLocking locking = (FeatureLocking) store;
-                                    locking.unLockFeatures(filter);
-                                }
-                            }
-
-                            // Post process - check features for changed boundary and
-                            // pass them off to the ValidationProcessor
-                            //
-                            if (!fids.isEmpty()) {
-                                LOGGER.finer(
-                                    "Post process update for boundary update and featureValidation");
-
-                                FilterFactory ff = CommonFactoryFinder.getFilterFactory(null);
-                                Set featureIds = new HashSet();
-
-                                for (Iterator f = fids.iterator(); f.hasNext();) {
-                                    featureIds.add(ff.featureId((String) f.next()));
-                                }
-
-                                Id modified = ff.id(featureIds);
-
-                                FeatureCollection changed = store.getFeatures(modified);
-                                envelope.expandToInclude(changed.getBounds());
-
-                                //featureValidation(typeInfo.getDataStore().getId(),store.getSchema(), changed);                    
-                            }
-
-                            //update the update counter
-                            updated += fids.size();
-                        } catch (IOException ioException) {
-                            //JD: changing from throwing service exception to adding action that failed
-                            throw new WFSTransactionException(ioException, null, handle);
-                        }
-                    } //end update
-                } else {
-                    //insert
-                    if ((wfs.getServiceLevel() & WFS.SERVICE_INSERT) == 0) {
-                        // could we catch this during the handler, rather than during execution?
-                        throw new WFSException("Transaction INSERT support is not enabled");
-                    }
-
-                    LOGGER.finer("Transasction Insert:" + element);
-
-                    InsertElementType insert = (InsertElementType) element;
-
-                    try {
-                        //group features by their schmea
-                        HashMap /*<FeatureType,FeatureCollection>*/ schema2features = new HashMap();
-
-                        for (Iterator f = insert.getFeature().iterator(); f.hasNext();) {
-                            Feature feature = (Feature) f.next();
-                            FeatureType schema = feature.getFeatureType();
-                            FeatureCollection collection = (FeatureCollection) schema2features.get(schema);
-
-                            if (collection == null) {
-                                collection = new DefaultFeatureCollection(null, schema) {
-                                        };
-                                schema2features.put(schema, collection);
-                            }
-
-                            collection.add(feature);
-                        }
-
-                        //JD: change from set fo list because if inserting features into 
-                        // differnt feature stores, they could very well get given the same id
-                        //JD: change from list to map so that the map can later be processed and 
-                        // we can report the fids back in the same order as they were supplied
-                        HashMap schema2fids = new HashMap();
-
-                        for (Iterator c = schema2features.values().iterator(); c.hasNext();) {
-                            FeatureCollection collection = (FeatureCollection) c.next();
-                            FeatureType schema = collection.getSchema();
-
-                            QName elementName = new QName(schema.getNamespace().toString(),
-                                    schema.getTypeName());
-                            FeatureStore store = (FeatureStore) stores.get(elementName);
-
-                            if (store == null) {
-                                throw new WFSException("Could not locate FeatureStore for '"
-                                    + elementName + "'");
-                            }
-
-                            if (collection != null) {
-                                //reprojection
-                                CoordinateReferenceSystem target = schema.getDefaultGeometry()
-                                                                         .getCoordinateSystem();
-
-                                if (target == null) {
-                                    //default to 4326
-                                    //TODO: maybe we should throw an exception, or just not reproject
-                                    // at all
-                                    target = CRS.decode("EPSG:4326");
-                                }
-
-                                collection = new ReprojectingFeatureCollection(collection, target);
-
-                                // Need to use the namespace here for the lookup, due to our weird
-                                // prefixed internal typenames.  see 
-                                //   http://jira.codehaus.org/secure/ViewIssue.jspa?key=GEOS-143
-
-                                // Once we get our datastores making features with the correct namespaces
-                                // we can do something like this:
-                                // FeatureTypeInfo typeInfo = catalog.getFeatureTypeInfo(schema.getTypeName(), schema.getNamespace());
-                                // until then (when geos-144 is resolved) we're stuck with:
-                                //QName qName = (QName) typeNames.get( i );
-                                //FeatureTypeInfo typeInfo = 
-                                //catalog.featureType( qName.getPrefix(), qName.getLocalPart() );
-
-                                // this is possible with the insert hack above.
-                                LOGGER.finer("Use featureValidation to check contents of insert");
-
-                                //featureValidation( typeInfo.getDataStore().getId(), schema, collection );
-                                List fids = (List) schema2fids.get(schema.getTypeName());
-
-                                if (fids == null) {
-                                    fids = new LinkedList();
-                                    schema2fids.put(schema.getTypeName(), fids);
-                                }
-
-                                fids.addAll(store.addFeatures(collection));
-                            }
-
-                            //
-                            // Add to validation check envelope                                
-                            envelope.expandToInclude(collection.getBounds());
-                        }
-
-                        //report back fids, we need to keep the same order the fids were reported 
-                        // in the original feature collection
-                        InsertedFeatureType insertedFeature = null;
-
-                        for (Iterator f = insert.getFeature().iterator(); f.hasNext();) {
-                            Feature feature = (Feature) f.next();
-                            FeatureType schema = feature.getFeatureType();
-
-                            //get the next fid
-                            LinkedList fids = (LinkedList) schema2fids.get(schema.getTypeName());
-                            String fid = (String) fids.removeFirst();
-
-                            insertedFeature = WfsFactory.eINSTANCE.createInsertedFeatureType();
-                            insertedFeature.setHandle(insert.getHandle());
-                            insertedFeature.getFeatureId().add(filterFactory.featureId(fid));
-
-                            result.getInsertResults().getFeature().add(insertedFeature);
-                        }
-
-                        //update the insert counter
-                        inserted += insert.getFeature().size();
-                    } catch (IOException ioException) {
-                        String msg = "Error perfomring insert";
-                        throw new WFSTransactionException(msg, ioException, insert.getHandle());
-                    }
-                }
+                handler.execute(element, request, stores, result, multiplexer);
             }
         } catch (WFSTransactionException e) {
+            exception = true;
             LOGGER.log(Level.SEVERE, "Transaction failed", e);
 
-            //transaction failed, rollback
+            // transaction failed, rollback
             ActionType action = WfsFactory.eINSTANCE.createActionType();
 
             if (e.getCode() != null) {
@@ -719,76 +343,89 @@
             action.setLocator(e.getLocator());
             action.setMessage(e.getMessage());
             result.getTransactionResults().getAction().add(action);
-
-            //roll back the transaction
-            transaction.rollback();
-            transaction = null;
         }
 
-        if (transaction != null) {
-            //transaction succeeded
+        // commit
+        boolean committed = false;
 
-            //set the counts
-            result.getTransactionSummary().setTotalDeleted(BigInteger.valueOf(deleted));
-            result.getTransactionSummary().setTotalInserted(BigInteger.valueOf(inserted));
-            result.getTransactionSummary().setTotalUpdated(BigInteger.valueOf(updated));
+        try {
+            if (exception) {
+                transaction.rollback();
+            } else {
+                // inform plugins we're about to commit
+                for (Iterator it = transactionPlugins.iterator(); it.hasNext();) {
+                    TransactionPlugin tp = (TransactionPlugin) it.next();
+                    tp.beforeCommit();
+                }
 
-            //commit
-            try {
                 transaction.commit();
-            } finally {
-                transaction.close();
-                transaction = null;
-            }
+                committed = true;
 
-            // 
-            // Lets deal with the locks
-            //
-            // Q: Why talk to Data you ask
-            // A: Only class that knows all the DataStores
-            //
-            // We really need to ask all DataStores to release/refresh
-            // because we may have locked Features with this Authorizations
-            // on them, even though we did not refer to them in this transaction.
-            //
-            // Q: Why here, why now?
-            // A: The opperation was a success, and we have completed the opperation
-            //
-            // We also need to do this if the opperation is not a success,
-            // you can find this same code in the abort method
-            // 
-            if (request.getLockId() != null) {
-                if (request.getReleaseAction() == AllSomeType.ALL_LITERAL) {
-                    lockRelease(request.getLockId());
-                } else if (request.getReleaseAction() == AllSomeType.SOME_LITERAL) {
-                    lockRefresh(request.getLockId());
+                //                  
+                // Lets deal with the locks
+                //
+                // Q: Why talk to Data you ask
+                // A: Only class that knows all the DataStores
+                //
+                // We really need to ask all DataStores to release/refresh
+                // because we may have locked Features with this Authorizations
+                // on them, even though we did not refer to them in this
+                // transaction.
+                //
+                // Q: Why here, why now?
+                // A: The opperation was a success, and we have completed the
+                // opperation
+                //
+                // We also need to do this if the opperation is not a success,
+                // you can find this same code in the abort method
+                // 
+                if (request.getLockId() != null) {
+                    if (request.getReleaseAction() == AllSomeType.ALL_LITERAL) {
+                        lockRelease(request.getLockId());
+                    } else if (request.getReleaseAction() == AllSomeType.SOME_LITERAL) {
+                        lockRefresh(request.getLockId());
+                    }
                 }
             }
+        } finally {
+            transaction.close();
+            transaction = null;
         }
 
+        // inform plugins we're done
+        for (Iterator it = transactionPlugins.iterator(); it.hasNext();) {
+            TransactionPlugin tp = (TransactionPlugin) it.next();
+            tp.afterTransaction(committed);
+        }
+
         //        
-        //        if ( result.getTransactionResult().getStatus().getPARTIAL() != null ) {
-        //            throw new WFSException("Canceling PARTIAL response");
-        //        }
+        // if ( result.getTransactionResult().getStatus().getPARTIAL() != null )
+        // {
+        // throw new WFSException("Canceling PARTIAL response");
+        // }
         //        
-        //        try {
-        //        	if ( result.getTransactionResult().getStatus().getFAILED() != null ) {
-        //            	//transaction failed, roll it back
-        //            	transaction.rollback();
-        //            }
-        //        	else {
-        //        		transaction.commit();
-        //        		result.getTransactionResult().getStatus().setSUCCESS( WfsFactory.eINSTANCE.createEmptyType() );
-        //        	}
+        // try {
+        // if ( result.getTransactionResult().getStatus().getFAILED() != null )
+        // {
+        // //transaction failed, roll it back
+        // transaction.rollback();
+        // }
+        // else {
+        // transaction.commit();
+        // result.getTransactionResult().getStatus().setSUCCESS(
+        // WfsFactory.eINSTANCE.createEmptyType() );
+        // }
         //        	
-        //        }
-        //        finally {
-        //        	transaction.close();
-        //        	transaction = null;
-        //        }
+        // }
+        // finally {
+        // transaction.close();
+        // transaction = null;
+        // }
 
-        //JD: this is an issue with the spec, InsertResults must be present, even if no insert 
-        // occured, howwever insert results needs to have at least one "FeatureId" eliement, sp 
+        // JD: this is an issue with the spec, InsertResults must be present,
+        // even if no insert
+        // occured, howwever insert results needs to have at least one
+        // "FeatureId" eliement, sp
         // we create an FeatureId with an empty fid
         if (result.getInsertResults().getFeature().isEmpty()) {
             InsertedFeatureType insertedFeature = WfsFactory.eINSTANCE.createInsertedFeatureType();
@@ -801,10 +438,105 @@
 
         // we will commit in the writeTo method
         // after user has got the response
-        //response = build;
+        // response = build;
     }
 
-    /* (non-Javadoc)
+    /**
+     * Looks up the element handlers to be used for each element
+     *
+     * @param group
+     * @return
+     */
+    private Map gatherElementHandlers(FeatureMap group)
+        throws WFSTransactionException {
+        //JD: use a linked hashmap since the order of elements in a transaction
+        // must be respected
+        Map map = new LinkedHashMap();
+
+        for (Iterator it = group.iterator(); it.hasNext();) {
+            FeatureMap.Entry entry = (FeatureMap.Entry) it.next();
+            EObject element = (EObject) entry.getValue();
+            map.put(element, findElementHandler(element.getClass()));
+        }
+
+        return map;
+    }
+
+    /**
+     * Finds the best transaction element handler for the specified element type
+     * (the one matching the most specialized superclass of type)
+     *
+     * @param type
+     * @return
+     */
+    protected final TransactionElementHandler findElementHandler(Class type)
+        throws WFSTransactionException {
+        List matches = new ArrayList();
+
+        for (Iterator it = transactionElementHandlers.iterator(); it.hasNext();) {
+            TransactionElementHandler handler = (TransactionElementHandler) it.next();
+
+            if (handler.getElementClass().isAssignableFrom(type)) {
+                matches.add(handler);
+            }
+        }
+
+        if (matches.isEmpty()) {
+            // try to instantiate one
+            String msg = "No transaction element handler for : ( " + type + " )";
+            throw new WFSTransactionException(msg);
+        }
+
+        if (matches.size() > 1) {
+            // sort by class hierarchy
+            Comparator comparator = new Comparator() {
+                    public int compare(Object o1, Object o2) {
+                        TransactionElementHandler h1 = (TransactionElementHandler) o1;
+                        TransactionElementHandler h2 = (TransactionElementHandler) o2;
+
+                        if (h2.getElementClass().isAssignableFrom(h1.getElementClass())) {
+                            return -1;
+                        }
+
+                        return 1;
+                    }
+                };
+
+            Collections.sort(matches, comparator);
+        }
+
+        return (TransactionElementHandler) matches.get(0);
+    }
+
+    /**
+     * Creates a gt2 transaction used to execute the transaction call
+     *
+     * @return
+     */
+    protected DefaultTransaction getDatastoreTransaction(TransactionType request)
+    throws IOException {
+        DefaultTransaction transaction = new DefaultTransaction();
+        // use handle as the log messages
+        String username = "anonymous";
+        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
+        if(authentication != null) {
+            Object principal = authentication.getPrincipal();
+            if(principal instanceof UserDetails) {
+                username = ((UserDetails) principal).getUsername(); 
+            }
+        }
+        
+        // Ok, this is a hack. We assume there is only one versioning datastore, the postgis one,
+        // and that we can the following properties won't hurt transactio processing anyways...
+        transaction.putProperty("PgVersionedCommitAuthor", username);
+        transaction.putProperty("PgVersionedCommitMessage", request.getHandle());
+    
+        return transaction;
+    }
+
+    /*
+     * (non-Javadoc)
+     *
      * @see org.vfny.geoserver.responses.Response#abort()
      */
     public void abort(TransactionType request) {
@@ -870,4 +602,27 @@
         LockFeature lockFeature = new LockFeature(wfs, catalog);
         lockFeature.refresh(lockId);
     }
+
+    /**
+     * Bounces the single callback we got from transaction event handlers to all
+     * registered listeners
+     *
+     * @author Andrea Aime - TOPP
+     *
+     */
+    private class TransactionListenerMux implements TransactionListener {
+        public void dataStoreChange(List listeners, TransactionEvent event)
+            throws WFSException {
+            for (Iterator it = listeners.iterator(); it.hasNext();) {
+                TransactionListener listener = (TransactionListener) it.next();
+                listener.dataStoreChange(event);
+            }
+        }
+
+        public void dataStoreChange(TransactionEvent event)
+            throws WFSException {
+            dataStoreChange(transactionPlugins, event);
+            dataStoreChange(transactionListeners, event);
+        }
+    }
 }
Index: src/main/java/org/geoserver/wfs/GetCapabilities.java
===================================================================
--- src/main/java/org/geoserver/wfs/GetCapabilities.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/GetCapabilities.java	(working copy)
@@ -140,7 +140,7 @@
                 for (; v.hasNext();) {
                     Version current = (Version) v.next();
 
-                    if (current.compareTo(accepted.last()) < 0) {
+                    if (current.compareTo(accepted.last()) > 0) {
                         break;
                     }
 
Index: src/main/java/org/geoserver/wfs/GetFeature.java
===================================================================
--- src/main/java/org/geoserver/wfs/GetFeature.java	(revision 7645)
+++ src/main/java/org/geoserver/wfs/GetFeature.java	(working copy)
@@ -4,8 +4,17 @@
  */
 package org.geoserver.wfs;
 
-import com.vividsolutions.jts.geom.Envelope;
-import com.vividsolutions.jts.geom.Geometry;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.logging.Logger;
+
+import javax.xml.namespace.QName;
+
 import net.opengis.wfs.AllSomeType;
 import net.opengis.wfs.FeatureCollectionType;
 import net.opengis.wfs.GetFeatureType;
@@ -15,56 +24,48 @@
 import net.opengis.wfs.LockType;
 import net.opengis.wfs.QueryType;
 import net.opengis.wfs.WfsFactory;
-import org.geotools.data.DataStore;
+
+import org.geotools.data.DataUtilities;
 import org.geotools.data.DefaultQuery;
 import org.geotools.data.FeatureSource;
-import org.geotools.data.feature.FeatureAccess;
-import org.geotools.data.feature.FeatureSource2;
-import org.geotools.data.feature.adapter.FeatureCollectionAdapter;
-import org.geotools.data.feature.adapter.ISOFeatureTypeAdapter;
+import org.geotools.factory.CommonFactoryFinder;
+import org.geotools.factory.GeoTools;
 import org.geotools.feature.CollectionListener;
 import org.geotools.feature.FeatureCollection;
 import org.geotools.feature.FeatureIterator;
 import org.geotools.feature.FeatureList;
+import org.geotools.feature.FeatureType;
+import org.geotools.feature.GeometryAttributeType;
 import org.geotools.feature.IllegalAttributeException;
+import org.geotools.feature.SchemaException;
 import org.geotools.feature.iso.FeatureCollections;
-import org.geotools.feature.iso.Types;
-import org.geotools.feature.iso.simple.SimpleFeatureFactoryImpl;
-import org.geotools.feature.iso.type.AttributeDescriptorImpl;
 import org.geotools.feature.visitor.FeatureVisitor;
+import org.geotools.filter.expression.AbstractExpressionVisitor;
+import org.geotools.filter.visitor.AbstractFilterVisitor;
 import org.geotools.geometry.jts.ReferencedEnvelope;
 import org.geotools.referencing.CRS;
 import org.geotools.util.ProgressListener;
 import org.geotools.xml.EMFUtils;
-import org.opengis.feature.simple.SimpleFeatureFactory;
-import org.opengis.feature.simple.SimpleFeatureType;
 import org.opengis.feature.type.AttributeDescriptor;
-import org.opengis.feature.type.FeatureType;
-import org.opengis.feature.type.GeometryType;
-import org.opengis.feature.type.Name;
 import org.opengis.filter.Filter;
 import org.opengis.filter.FilterFactory;
+import org.opengis.filter.FilterFactory2;
+import org.opengis.filter.expression.ExpressionVisitor;
+import org.opengis.filter.expression.PropertyName;
 import org.opengis.filter.sort.SortBy;
 import org.opengis.referencing.crs.CoordinateReferenceSystem;
 import org.vfny.geoserver.global.AttributeTypeInfo;
 import org.vfny.geoserver.global.Data;
 import org.vfny.geoserver.global.FeatureTypeInfo;
-import java.io.IOException;
-import java.math.BigInteger;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.logging.Logger;
-import javax.xml.namespace.QName;
 
+import com.vividsolutions.jts.geom.Geometry;
 
+
 /**
  * Web Feature Service GetFeature operation.
  * <p>
- * This operation returns an array of
- * {@link org.geotools.feature.FeatureCollection} instances.
+ * This operation returns an array of {@link org.geotools.feature.FeatureCollection}
+ * instances.
  * </p>
  *
  * @author Rob Hranac, TOPP
@@ -74,10 +75,10 @@
  */
 public class GetFeature {
     /**
-     * This is a temporary wraper for the ISO Features collections implementing
+     * This is a temporary wrapper for the ISO Features collections implementing
      * geotools FeatureCollection so there's no need to modify or fork the WFS
      * emf generated classes. In other words, this is a HACK and has to die once
-     * we get an homogeinized feature model.
+     * we get an homogenized feature model.
      *
      * @author gabriel
      */
@@ -320,16 +321,18 @@
         //
         // And allways remember to release locks if we are failing:
         // - if we fail to aquire all the locks we will need to fail and
-        // itterate through the the FeatureSources to release the locks
+        //   itterate through the the FeatureSources to release the locks
         //
         if (request.getMaxFeatures() == null) {
             request.setMaxFeatures(BigInteger.valueOf(Integer.MAX_VALUE));
         }
 
-        int maxFeatures = request.getMaxFeatures().intValue();
+        // take into consideration the wfs max features
+        int maxFeatures = Math.min(request.getMaxFeatures().intValue(),
+                wfs.getGeoServer().getMaxFeatures());
 
         FeatureCollectionType result = WfsFactory.eINSTANCE.createFeatureCollectionType();
-        int count = 0; // should probably be long
+        int count = 0; //should probably be long
 
         try {
             for (int i = 0; (i < request.getQuery().size()) && (count <= maxFeatures); i++) {
@@ -340,19 +343,21 @@
                 if (query.getTypeName().size() == 1) {
                     meta = featureTypeInfo((QName) query.getTypeName().get(0));
                 } else {
-                    // TODO: a join is taking place
+                    //TODO: a join is taking place
                 }
 
+                FeatureSource source = meta.getFeatureSource();
+
                 List atts = meta.getAttributes();
                 List attNames = meta.getAttributeNames();
 
-                // make sure property names are cool
+                //make sure property names are cool
                 List propNames = query.getPropertyName();
 
                 for (Iterator iter = propNames.iterator(); iter.hasNext();) {
                     String propName = (String) iter.next();
 
-                    // HACK: strip off namespace
+                    //HACK: strip off namespace
                     if (propName.indexOf(':') != -1) {
                         propName = propName.substring(propName.indexOf(':') + 1);
                     }
@@ -366,96 +371,103 @@
                     }
                 }
 
-                // we must also include any properties that are mandatory ( even
-                // if not requested ),
+                //we must also include any properties that are mandatory ( even if not requested ),
                 // ie. those with minOccurs > 0
+                List extraGeometries = new ArrayList();
+                List properties = new ArrayList();
                 if (propNames.size() != 0) {
                     Iterator ii = atts.iterator();
-                    List tmp = new LinkedList();
 
                     while (ii.hasNext()) {
                         AttributeTypeInfo ati = (AttributeTypeInfo) ii.next();
                         LOGGER.finer("checking to see if " + propNames + " contains" + ati);
 
                         if (((ati.getMinOccurs() > 0) && (ati.getMaxOccurs() != 0))) {
-                            // mandatory, add it
-                            tmp.add(ati.getName());
+                            //mandatory, add it
+                            properties.add(ati.getName());
 
                             continue;
                         }
 
-                        // check if it was requested
+                        //check if it was requested
                         for (Iterator p = propNames.iterator(); p.hasNext();) {
                             String propName = (String) p.next();
 
                             if (propName.matches("(\\w+:)?" + ati.getName())) {
-                                tmp.add(ati.getName());
-
+                                properties.add(ati.getName());
                                 break;
                             }
                         }
+                        
+                        // if we need to force feature bounds computation, we have to load 
+                        // all of the geometries, but we'll have to remove them in the 
+                        // returned feature type
+                        if(wfs.isFeatureBounding() && meta.getFeatureType().getAttributeType(ati.getName()) instanceof GeometryAttributeType
+                                && !properties.contains(ati.getName())) {
+                            properties.add(ati.getName());
+                            extraGeometries.add(ati.getName());
+                        }
                     }
 
-                    // replace property names
+                    //replace property names
                     query.getPropertyName().clear();
-                    query.getPropertyName().addAll(tmp);
+                    query.getPropertyName().addAll(properties);
                 }
 
-                DataStore dataStore = meta.getDataStoreInfo().getDataStore();
-                String typeName = meta.getTypeName();
+                //make sure filters are sane
+                if (query.getFilter() != null) {
+                    final FeatureType featureType = source.getSchema();
+                    ExpressionVisitor visitor = new AbstractExpressionVisitor() {
+                            public Object visit(PropertyName name, Object data) {
+                                // case of multiple geometries being returned
+                                if (name.evaluate(featureType) == null) {
+                                    //we want to throw wfs exception, but cant
+                                    throw new WFSException("Illegal property name: "
+                                        + name.getPropertyName(), "InvalidParameterValue");
+                                }
 
-                final FeatureSource source;
-                final FeatureType featureType;
-                final org.opengis.feature.FeatureCollection features;
+                                return name;
+                            }
+                            ;
+                        };
 
-                AttributeDescriptor descriptor;
-
-                if (dataStore instanceof FeatureAccess) {
-                    String uri = meta.getNameSpace().getURI();
-                    Name name = Types.typeName(uri, typeName);
-                    source = (FeatureSource2) ((FeatureAccess) dataStore).access(name);
-
-                    descriptor = (AttributeDescriptor) ((FeatureSource2) source).describe();
-                    featureType = (FeatureType) descriptor.getType();
-                } else {
-                    source = dataStore.getFeatureSource(typeName);
-                    featureType = new ISOFeatureTypeAdapter(source.getSchema());
-
-                    Name tname = featureType.getName();
-                    Name name = Types.typeName(tname.getNamespaceURI(), tname.getLocalPart());
-                    descriptor = new AttributeDescriptorImpl(featureType, name, 0,
-                            Integer.MAX_VALUE, true, null);
+                    query.getFilter().accept(new AbstractFilterVisitor(visitor), null);
                 }
 
-                int queryMaxFeatures = maxFeatures - count;
-                org.geotools.data.Query gtQuery = toDataQuery(query, queryMaxFeatures, featureType);
+                org.geotools.data.Query gtQuery = toDataQuery(query, maxFeatures - count, source);
                 LOGGER.fine("Query is " + query + "\n To gt2: " + gtQuery);
 
-                if (source instanceof FeatureSource2) {
-                    Filter filter = gtQuery.getFilter();
-                    FeatureSource2 fsource = (FeatureSource2) source;
-                    features = (org.opengis.feature.FeatureCollection) fsource.content(filter,
-                            queryMaxFeatures);
-                } else {
-                    FeatureCollection gtFeatures = source.getFeatures(gtQuery);
-                    SimpleFeatureFactory featureFactory = new SimpleFeatureFactoryImpl();
-                    features = new FeatureCollectionAdapter((SimpleFeatureType) featureType,
-                            gtFeatures, featureFactory);
-                    ((FeatureCollectionAdapter) features).setMaxFeatures(queryMaxFeatures);
+                FeatureCollection features = source.getFeatures(gtQuery);
+                count += features.size();
+                
+                // we may need to shave off geometries we did load only to make bounds
+                // computation happy
+                if(extraGeometries.size() > 0) {
+                    List residualProperties = new ArrayList(properties);
+                    residualProperties.removeAll(extraGeometries);
+                    String[] residualNames = (String[]) residualProperties.toArray(new String[residualProperties.size()]);
+                    FeatureType targetType = DataUtilities.createSubType(features.getSchema(), residualNames);
+                    features = new FeatureBoundsFeatureCollection(features, targetType);
                 }
 
-                count += FeatureCollections.getSize(features);
+                //JD: TODO reoptimize
+                //                if ( i == request.getQuery().size() - 1 ) { 
+                //                	//DJB: dont calculate feature count if you dont have to. The MaxFeatureReader will take care of the last iteration
+                //                	maxFeatures -= features.getCount();
+                //                }
 
-                FeatureCollection hackFeatureCollection = new GTHackFeatureCollection(features,
-                        descriptor);
-
-                result.getFeature().add(hackFeatureCollection);
+                //GR: I don't know if the featuresults should be added here for later
+                //encoding if it was a lock request. may be after ensuring the lock
+                //succeed?
+                result.getFeature().add(features);
             }
         } catch (IOException e) {
             throw new WFSException("Error occurred getting features", e, request.getHandle());
+        } catch (SchemaException e) {
+            throw new WFSException("Error occurred getting features", e, request.getHandle());
         }
 
-        // locking
+        //locking
         if (request instanceof GetFeatureWithLockType) {
             GetFeatureWithLockType withLockRequest = (GetFeatureWithLockType) request;
 
@@ -471,7 +483,7 @@
                 lock.setFilter(query.getFilter());
                 lock.setHandle(query.getHandle());
 
-                // TODO: joins?
+                //TODO: joins?
                 lock.setTypeName((QName) query.getTypeName().get(0));
                 lockRequest.getLock().add(lock);
             }
@@ -498,18 +510,17 @@
      * </p>
      *
      * <p>
-     * The method name is changed to toDataStoreQuery since this is a one way
+     * The method name is changed to toDataQuery since this is a one way
      * conversion.
      * </p>
      *
-     * @param maxFeatures
-     *            number of features, or 0 for DefaultQuery.DEFAULT_MAX
+     * @param maxFeatures number of features, or 0 for DefaultQuery.DEFAULT_MAX
      *
      * @return A Query for use with the FeatureSource interface
      *
      */
-    public org.geotools.data.Query toDataQuery(QueryType query, int maxFeatures, FeatureType schema)
-        throws WFSException {
+    public org.geotools.data.Query toDataQuery(QueryType query, int maxFeatures,
+        FeatureSource source) throws WFSException {
         if (maxFeatures <= 0) {
             maxFeatures = DefaultQuery.DEFAULT_MAX;
         }
@@ -530,31 +541,33 @@
         if (filter == null) {
             filter = Filter.INCLUDE;
         }
+        
+        // make sure filters are expressed in the data native CRS
+        FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());
+        ReprojectingFilterVisitor visitor = new ReprojectingFilterVisitor(ff, source.getSchema());
+        Filter transformedFilter = (Filter) filter.accept(visitor, null);
 
-        // only handle non-joins for now
+        //only handle non-joins for now
         QName typeName = (QName) query.getTypeName().get(0);
-        DefaultQuery dataQuery = new DefaultQuery(typeName.getLocalPart(), filter, maxFeatures,
+        DefaultQuery dataQuery = new DefaultQuery(typeName.getLocalPart(), transformedFilter, maxFeatures,
                 props, query.getHandle());
 
-        AttributeDescriptor defaultGeometry = schema.getDefaultGeometry();
-        GeometryType geomType = (GeometryType) ((defaultGeometry == null) ? null
-                                                                          : defaultGeometry.getType());
+        //figure out the crs the data is in
+        CoordinateReferenceSystem crs = (source.getSchema().getDefaultGeometry() != null)
+            ? source.getSchema().getDefaultGeometry().getCoordinateSystem() : null;
 
-        // figure out the crs the data is in
-        CoordinateReferenceSystem crs = (geomType == null) ? null : geomType.getCRS();
-
         if (crs == null) {
-            // set to be the server default
+            //set to be the server default
             try {
                 crs = CRS.decode("EPSG:4326");
                 dataQuery.setCoordinateSystem(crs);
             } catch (Exception e) {
-                // should never happen
+                //should never happen
                 throw new RuntimeException(e);
             }
         }
 
-        // handle reprojection
+        //handle reprojection
         if (query.getSrsName() != null) {
             CoordinateReferenceSystem target;
 
@@ -565,18 +578,23 @@
                 throw new WFSException(msg, e);
             }
 
-            // if the crs are not equal, then reproject
+            //if the crs are not equal, then reproject
             if (!crs.equals(target)) {
-                dataQuery.setCoordinateSystemReproject(crs);
+                dataQuery.setCoordinateSystemReproject(target);
             }
         }
-
-        // handle sorting
+        
+        //handle sorting
         if (query.getSortBy() != null) {
             List sortBy = query.getSortBy();
             dataQuery.setSortBy((SortBy[]) sortBy.toArray(new SortBy[sortBy.size()]));
         }
 
+        //handle version, datastore may be able to use it
+        if (query.getFeatureVersion() != null) {
+            dataQuery.setVersion(query.getFeatureVersion());
+        }
+
         return dataQuery;
     }
 
Index: src/main/java/org/vfny/geoserver/wfs/servlets/TestWfsPost.java
===================================================================
--- src/main/java/org/vfny/geoserver/wfs/servlets/TestWfsPost.java	(revision 7645)
+++ src/main/java/org/vfny/geoserver/wfs/servlets/TestWfsPost.java	(working copy)
@@ -4,6 +4,7 @@
  */
 package org.vfny.geoserver.wfs.servlets;
 
+import org.apache.commons.codec.binary.Base64;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.IOException;
@@ -196,6 +197,15 @@
                 //DJB: applied patch in GEOS-335
                 String authHeader = request.getHeader("Authorization");
 
+                String username = request.getParameter("username");
+
+                if ((username != null) && !username.trim().equals("")) {
+                    String password = request.getParameter("password");
+                    String up = username + ":" + password;
+                    byte[] encoded = Base64.encodeBase64(up.getBytes());
+                    authHeader = "Basic " + new String(encoded);
+                }
+
                 if (authHeader != null) {
                     acon.setRequestProperty("Authorization", authHeader);
                 }
Index: src/main/java/applicationContext.xml
===================================================================
--- src/main/java/applicationContext.xml	(revision 7645)
+++ src/main/java/applicationContext.xml	(working copy)
@@ -61,6 +61,23 @@
 	  	</list>
 	  </property>
 	</bean>
+  
+    <!-- Transaction element handlers -->
+    <bean id="wfsInsertElementHandler" class="org.geoserver.wfs.InsertElementHandler">
+      <constructor-arg ref="wfs"/>
+      <constructor-arg ref="filterFactory"/>
+    </bean>
+    
+    <bean id="wfsUpdateElementHandler" class="org.geoserver.wfs.UpdateElementHandler">
+      <constructor-arg ref="wfs"/>
+    </bean>
+    
+    <bean id="wfsDeleteElementHandler" class="org.geoserver.wfs.DeleteElementHandler">
+      <constructor-arg ref="wfs"/>
+    </bean>
+    
+    <bean id="wfsNativeElementHandler" class="org.geoserver.wfs.NativeElementHandler">
+    </bean>
 		
 	<!-- service descriptors -->
 	<bean id="wfsService-1.0.0" class="org.geoserver.platform.Service">
@@ -81,7 +98,7 @@
 			<list>
 				<ref bean="wfsService-1.0.0"/>
 				<ref bean="wfsService-1.1.0"/>
-			</list>
+			</list>		
 		</constructor-arg>	
 		<constructor-arg ref="wfs"/>
 	</bean>
@@ -132,6 +149,7 @@
 	<!-- http url mapping -->
 	<bean id="wfsURLMapping" 
 		class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
+        <property name="alwaysUseFullPath" value="true"/>
 		<property name="interceptors">
 			<list>
 				<ref bean="citeComplianceHack"/>
@@ -158,7 +176,8 @@
 	</bean>
 	
 	<bean id="bboxKvpParser" class="org.geoserver.wfs.kvp.BBoxKvpParser"/>
-	<bean id="filterKvpParser" class="org.geoserver.wfs.kvp.FilterKvpReader"/>
+	<bean id="filterKvpParser" class="org.geoserver.wfs.kvp.FilterKvpParser"/>
+    <bean id="cqlKvpParser" class="org.geoserver.wfs.kvp.CQLFilterKvpParser"/>
 	<bean id="propertyNameKvpParser" class="org.geoserver.ows.NestedKvpParser">
 		<constructor-arg index="0" value="propertyName"/>
 		<constructor-arg index="1" value="java.lang.String"/>
@@ -168,10 +187,7 @@
 		<constructor-arg index="1" value="java.math.BigInteger"/>
 	</bean>
 	
-	<bean id="srsNameFeatureKvpParser" class="org.geoserver.ows.FlatKvpParser">
-		<constructor-arg index="0" value="srsName"/>
-		<constructor-arg index="1" value="java.lang.String"/>
-	</bean>
+	<bean id="srsNameKvpParser" class="org.geoserver.wfs.kvp.SrsNameKvpParser"/>
 	<bean id="sortByKvpParser" class="org.geoserver.wfs.kvp.SortByKvpParser">
 		<constructor-arg ref="filterFactory"/>
 	</bean>
@@ -289,6 +305,6 @@
 		<constructor-arg ref="wfs"/>
 		<constructor-arg ref="xmlConfiguration-1.1"/>
 	</bean>
-		
-
+	<bean id="shapezipOutputFormat" class="org.geoserver.wfs.response.ShapeZipOutputFormat" />
+    <bean id="geojsonOutputFormat" class="org.geoserver.wfs.response.GeoJSONOutputFormat"/>
 </beans>
\ No newline at end of file
Index: .springBeans
===================================================================
--- .springBeans	(revision 7645)
+++ .springBeans	(working copy)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<beansProjectDescription>
-	<configExtensions>
-		<configExtension>xml</configExtension>
-	</configExtensions>
-	<configs>
-		<config>src/main/java/applicationContext.xml</config>
-	</configs>
-	<configSets>
-	</configSets>
-</beansProjectDescription>
